0000                             ;**************************************************************
0000                             ;*
0000                             ;*             C P / M   version   2 . 2
0000                             ;*
0000                             ;*   Reconstructed from memory image on February 27, 1981
0000                             ;*
0000                             ;*                by Clark A. Calkins
0000                             ;*
0000                             ;**************************************************************
0000                             ; 
0000                             ;       BIOS EQUES
0000                CCP:      EQU   0DC00h   ;base of ccp
0000                BDOS:     EQU   0E400h   ;base of bdos
0000                BIOS:     EQU   0F200h   ;base of bios
0000                CDISK:    EQU   8004h   ;current disk number 0=a,... l5=p
0000                IOBYTE:   EQU   8003h   ;intel i/o byte
0000                             ;   Set memory limit here. This is the amount of contigeous
0000                             ; ram starting from 0000. CP/M will reside at the end of this space.
0000                             ; 
0000                MEM:      EQU   62   ;for a 62k system (TS802 TEST - WORKS OK).
0000                             ; 
0000                IOBYTE:   EQU   8003h   ;i/o definition byte.
0000                TDRIVE:   EQU   8004h   ;current drive name and user number.
0000                ENTRY:    EQU   8005h   ;entry point for the cp/m bdos.
0000                TFCB:     EQU   805Ch   ;default file control block.
0000                TBUFF:    EQU   8080H   ;i/o buffer and command line storage.
0000                TBASE:    EQU   8100H   ;transiant program storage area.
0000                DEFSTCK:   EQU   8080h   
0000                             ; 
0000                             ;   Set control character equates.
0000                             ; 
0000                CNTRLC:   EQU   3   ;control-c
0000                CNTRLE:   EQU   05H   ;control-e
0000                BS:       EQU   08H   ;backspace
0000                TAB:      EQU   09H   ;tab
0000                LF:       EQU   0AH   ;line feed
0000                FF:       EQU   0CH   ;form feed
0000                CR:       EQU   0DH   ;carriage return
0000                CNTRLP:   EQU   10H   ;control-p
0000                CNTRLR:   EQU   12H   ;control-r
0000                CNTRLS:   EQU   13H   ;control-s
0000                CNTRLU:   EQU   15H   ;control-u
0000                CNTRLX:   EQU   18H   ;control-x
0000                CNTRLZ:   EQU   1AH   ;control-z (end-of-file mark)
0000                DEL:      EQU   7FH   ;rubout
0000                             ; 
8000                          .ORG   8000h   
8000   C3 A7 F2               JMP   WBOOT   
8003   00 00                  DB   00,00   
8005                          .ORG   8005h   
8005   C3 00 E4               JMP   BDOS   
803C                          .ORG   803Ch   
803C   C3 F0 F3               JMP   RECINTLOW   
803F                             ;   Set origin for CP/M
803F                             ; 
DC00                          .ORG   CCP   
DC00                             ; 
DC00   C3 5C DF     CBASE:    JMP   COMMAND   ;execute command processor (ccp).
DC03   C3 58 DF               JMP   CLEARBUF   ;entry to empty input buffer before starting ccp.
DC06                             ; 
DC06                             ;   Standard cp/m ccp input buffer. Format is (max length),
DC06                             ; (actual length), (char #1), (char #2), (char #3), etc.
DC06                             ; 
DC06   7F           INBUFF:   DB   127   ;length of input buffer.
DC07   00                     DB   0   ;current length of contents.
DC08   43 6F 70 79 72 69 67 68 74 DB   "Copyright"   
DC11   20 31 39 37 39 20 28 63 29 20 62 79 20 44 69 67 69 74 61 6C 20 52 65 73 65 61 72 63 68 20 20 20 20 20 20 DB   " 1979 (c) by Digital Research      "   
DC34   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC4B   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC62   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC79   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
DC88   08 DC        INPOINT:   DW   INBUFF+2   ;input line pointer
DC8A   00 00        NAMEPNT:   DW   0   ;input line pointer used for error message. Points to
DC8C                             ;			;start of name in error.
DC8C                             ; 
DC8C                             ;   Routine to print (A) on the console. All registers used.
DC8C                             ; 
DC8C   5F           PRINT:    MOV   E,A   ;setup bdos call.
DC8D   0E 02                  MVI   C,2   
DC8F   C3 05 80               JMP   ENTRY   
DC92                             ; 
DC92                             ;   Routine to print (A) on the console and to save (BC).
DC92                             ; 
DC92   C5           PRINTB:   PUSH   B   
DC93   CD 8C DC               CALL   PRINT   
DC96   C1                     POP   B   
DC97   C9                     RET      
DC98                             ; 
DC98                             ;   Routine to send a carriage return, line feed combination
DC98                             ; to the console.
DC98                             ; 
DC98   3E 0D        CRLF:     MVI   A,CR   
DC9A   CD 92 DC               CALL   PRINTB   
DC9D   3E 0A                  MVI   A,LF   
DC9F   C3 92 DC               JMP   PRINTB   
DCA2                             ; 
DCA2                             ;   Routine to send one space to the console and save (BC).
DCA2                             ; 
DCA2   3E 20        SPACE:    MVI   A," "   
DCA4   C3 92 DC               JMP   PRINTB   
DCA7                             ; 
DCA7                             ;   Routine to print character string pointed to be (BC) on the
DCA7                             ; console. It must terminate with a null byte.
DCA7                             ; 
DCA7   C5           PLINE:    PUSH   B   
DCA8   CD 98 DC               CALL   CRLF   
DCAB   E1                     POP   H   
DCAC   7E           PLINE2:   MOV   A,M   
DCAD   B7                     ORA   A   
DCAE   C8                     RZ      
DCAF   23                     INX   H   
DCB0   E5                     PUSH   H   
DCB1   CD 8C DC               CALL   PRINT   
DCB4   E1                     POP   H   
DCB5   C3 AC DC               JMP   PLINE2   
DCB8                             ; 
DCB8                             ;   Routine to reset the disk system.
DCB8                             ; 
DCB8   0E 0D        RESDSK:   MVI   C,13   
DCBA   C3 05 80               JMP   ENTRY   
DCBD                             ; 
DCBD                             ;   Routine to select disk (A).
DCBD                             ; 
DCBD   5F           DSKSEL:   MOV   E,A   
DCBE   0E 0E                  MVI   C,14   
DCC0   C3 05 80               JMP   ENTRY   
DCC3                             ; 
DCC3                             ;   Routine to call bdos and save the return code. The zero
DCC3                             ; flag is set on a return of 0ffh.
DCC3                             ; 
DCC3   CD 05 80     ENTRY1:   CALL   ENTRY   
DCC6   32 EE E3               STA   RTNCODE   ;save return code.
DCC9   3C                     INR   A   ;set zero if 0ffh returned.
DCCA   C9                     RET      
DCCB                             ; 
DCCB                             ;   Routine to open a file. (DE) must point to the FCB.
DCCB                             ; 
DCCB   0E 0F        OPEN:     MVI   C,15   
DCCD   C3 C3 DC               JMP   ENTRY1   
DCD0                             ; 
DCD0                             ;   Routine to open file at (FCB).
DCD0                             ; 
DCD0   AF           OPENFCB:   XRA   A   ;clear the record number byte at TFCB+32
DCD1   32 7C 80               STA   TFCB+32   
DCD4   11 5C 80               LXI   D,TFCB   
DCD7   C3 CB DC               JMP   OPEN   
DCDA                             ; 
DCDA                             ;   Routine to close a file. (DE) points to TFCB.
DCDA                             ; 
DCDA   0E 10        CLOSE:    MVI   C,16   
DCDC   C3 C3 DC               JMP   ENTRY1   
DCDF                             ; 
DCDF                             ;   Routine to search for the first file with ambigueous name
DCDF                             ; (DE).
DCDF                             ; 
DCDF   0E 11        SRCHFST:   MVI   C,17   
DCE1   C3 C3 DC               JMP   ENTRY1   
DCE4                             ; 
DCE4                             ;   Search for the next ambigeous file name.
DCE4                             ; 
DCE4   0E 12        SRCHNXT:   MVI   C,18   
DCE6   C3 C3 DC               JMP   ENTRY1   
DCE9                             ; 
DCE9                             ;   Search for file at (TFCB).
DCE9                             ; 
DCE9   11 5C 80     SRCHFCB:   LXI   D,TFCB   
DCEC   C3 DF DC               JMP   SRCHFST   
DCEF                             ; 
DCEF                             ;   Routine to delete a file pointed to by (DE).
DCEF                             ; 
DCEF   0E 13        DELETE:   MVI   C,19   
DCF1   C3 05 80               JMP   ENTRY   
DCF4                             ; 
DCF4                             ;   Routine to call the bdos and set the zero flag if a zero
DCF4                             ; status is returned.
DCF4                             ; 
DCF4   CD 05 80     ENTRY2:   CALL   ENTRY   
DCF7   B7                     ORA   A   ;set zero flag if appropriate.
DCF8   C9                     RET      
DCF9                             ; 
DCF9                             ;   Routine to read the next record from a sequential file.
DCF9                             ; (DE) points to the FCB.
DCF9                             ; 
DCF9   0E 14        RDREC:    MVI   C,20   
DCFB   C3 F4 DC               JMP   ENTRY2   
DCFE                             ; 
DCFE                             ;   Routine to read file at (FCB).
DCFE                             ; 
DCFE   11 5C 80     READFCB:   LXI   D,TFCB   
DD01   C3 F9 DC               JMP   RDREC   
DD04                             ; 
DD04                             ;   Routine to write the next record of a sequential file.
DD04                             ; (DE) points to the FCB.
DD04                             ; 
DD04   0E 15        WRTREC:   MVI   C,21   
DD06   C3 F4 DC               JMP   ENTRY2   
DD09                             ; 
DD09                             ;   Routine to create the file pointed to by (DE).
DD09                             ; 
DD09   0E 16        CREATE:   MVI   C,22   
DD0B   C3 C3 DC               JMP   ENTRY1   
DD0E                             ; 
DD0E                             ;   Routine to rename the file pointed to by (DE). Note that
DD0E                             ; the new name starts at (DE+16).
DD0E                             ; 
DD0E   0E 17        RENAM:    MVI   C,23   
DD10   C3 05 80               JMP   ENTRY   
DD13                             ; 
DD13                             ;   Get the current user code.
DD13                             ; 
DD13   1E FF        GETUSR:   MVI   E,0FFH   
DD15                             ; 
DD15                             ;   Routne to get or set the current user code.
DD15                             ; If (E) is FF then this is a GET, else it is a SET.
DD15                             ; 
DD15   0E 20        GETSETUC:   MVI   C,32   
DD17   C3 05 80               JMP   ENTRY   
DD1A                             ; 
DD1A                             ;   Routine to set the current drive byte at (TDRIVE).
DD1A                             ; 
DD1A   CD 13 DD     SETCDRV:   CALL   GETUSR   ;get user number
DD1D   87                     ADD   A   ;and shift into the upper 4 bits.
DD1E   87                     ADD   A   
DD1F   87                     ADD   A   
DD20   87                     ADD   A   
DD21   21 EF E3               LXI   H,CDRIVE   ;now add in the current drive number.
DD24   B6                     ORA   M   
DD25   32 04 80               STA   TDRIVE   ;and save.
DD28   C9                     RET      
DD29                             ; 
DD29                             ;   Move currently active drive down to (TDRIVE).
DD29                             ; 
DD29   3A EF E3     MOVECD:   LDA   CDRIVE   
DD2C   32 04 80               STA   TDRIVE   
DD2F   C9                     RET      
DD30                             ; 
DD30                             ;   Routine to convert (A) into upper case ascii. Only letters
DD30                             ; are affected.
DD30                             ; 
DD30   FE 61        UPPER:    CPI   "a"   ;check for letters in the range of "a" to "z".
DD32   D8                     RC      
DD33   FE 7B                  CPI   "{"   
DD35   D0                     RNC      
DD36   E6 5F                  ANI   5FH   ;convert it if found.
DD38   C9                     RET      
DD39                             ; 
DD39                             ;   Routine to get a line of input. We must check to see if the
DD39                             ; user is in (BATCH) mode. If so, then read the input from file
DD39                             ; ($$$.SUB). At the end, reset to console input.
DD39                             ; 
DD39   3A AB E3     GETINP:   LDA   BATCH   ;if =0, then use console input.
DD3C   B7                     ORA   A   
DD3D   CA 96 DD               JZ   GETINP1   
DD40                             ; 
DD40                             ;   Use the submit file ($$$.sub) which is prepared by a
DD40                             ; SUBMIT run. It must be on drive (A) and it will be deleted
DD40                             ; if and error occures (like eof).
DD40                             ; 
DD40   3A EF E3               LDA   CDRIVE   ;select drive 0 if need be.
DD43   B7                     ORA   A   
DD44   3E 00                  MVI   A,0   ;always use drive A for submit.
DD46   C4 BD DC               CNZ   DSKSEL   ;select it if required.
DD49   11 AC E3               LXI   D,BATCHFCB   
DD4C   CD CB DC               CALL   OPEN   ;look for it.
DD4F   CA 96 DD               JZ   GETINP1   ;if not there, use normal input.
DD52   3A BB E3               LDA   BATCHFCB+15   ;get last record number+1.
DD55   3D                     DCR   A   
DD56   32 CC E3               STA   BATCHFCB+32   
DD59   11 AC E3               LXI   D,BATCHFCB   
DD5C   CD F9 DC               CALL   RDREC   ;read last record.
DD5F   C2 96 DD               JNZ   GETINP1   ;quit on end of file.
DD62                             ; 
DD62                             ;   Move this record into input buffer.
DD62                             ; 
DD62   11 07 DC               LXI   D,INBUFF+1   
DD65   21 80 80               LXI   H,TBUFF   ;data was read into buffer here.
DD68   06 80                  MVI   B,128   ;all 128 characters may be used.
DD6A   CD 42 E0               CALL   HL2DE   ;(HL) to (DE), (B) bytes.
DD6D   21 BA E3               LXI   H,BATCHFCB+14   
DD70   36 00                  MVI   M,0   ;zero out the "s2" byte.
DD72   23                     INX   H   ;and decrement the record count.
DD73   35                     DCR   M   
DD74   11 AC E3               LXI   D,BATCHFCB   ;close the batch file now.
DD77   CD DA DC               CALL   CLOSE   
DD7A   CA 96 DD               JZ   GETINP1   ;quit on an error.
DD7D   3A EF E3               LDA   CDRIVE   ;re-select previous drive if need be.
DD80   B7                     ORA   A   
DD81   C4 BD DC               CNZ   DSKSEL   ;don't do needless selects.
DD84                             ; 
DD84                             ;   Print line just read on console.
DD84                             ; 
DD84   21 08 DC               LXI   H,INBUFF+2   
DD87   CD AC DC               CALL   PLINE2   
DD8A   CD C2 DD               CALL   CHKCON   ;check console, quit on a key.
DD8D   CA A7 DD               JZ   GETINP2   ;jump if no key is pressed.
DD90                             ; 
DD90                             ;   Terminate the submit job on any keyboard input. Delete this
DD90                             ; file such that it is not re-started and jump to normal keyboard
DD90                             ; input section.
DD90                             ; 
DD90   CD DD DD               CALL   DELBATCH   ;delete the batch file.
DD93   C3 82 DF               JMP   CMMND1   ;and restart command input.
DD96                             ; 
DD96                             ;   Get here for normal keyboard input. Delete the submit file
DD96                             ; incase there was one.
DD96                             ; 
DD96   CD DD DD     GETINP1:   CALL   DELBATCH   ;delete file ($$$.sub).
DD99   CD 1A DD               CALL   SETCDRV   ;reset active disk.
DD9C   0E 0A                  MVI   C,10   ;get line from console device.
DD9E   11 06 DC               LXI   D,INBUFF   
DDA1   CD 05 80               CALL   ENTRY   
DDA4   CD 29 DD               CALL   MOVECD   ;reset current drive (again).
DDA7                             ; 
DDA7                             ;   Convert input line to upper case.
DDA7                             ; 
DDA7   21 07 DC     GETINP2:   LXI   H,INBUFF+1   
DDAA   46                     MOV   B,M   ;(B)=character counter.
DDAB   23           GETINP3:   INX   H   
DDAC   78                     MOV   A,B   ;end of the line?
DDAD   B7                     ORA   A   
DDAE   CA BA DD               JZ   GETINP4   
DDB1   7E                     MOV   A,M   ;convert to upper case.
DDB2   CD 30 DD               CALL   UPPER   
DDB5   77                     MOV   M,A   
DDB6   05                     DCR   B   ;adjust character count.
DDB7   C3 AB DD               JMP   GETINP3   
DDBA   77           GETINP4:   MOV   M,A   ;add trailing null.
DDBB   21 08 DC               LXI   H,INBUFF+2   
DDBE   22 88 DC               SHLD   INPOINT   ;reset input line pointer.
DDC1   C9                     RET      
DDC2                             ; 
DDC2                             ;   Routine to check the console for a key pressed. The zero
DDC2                             ; flag is set is none, else the character is returned in (A).
DDC2                             ; 
DDC2   0E 0B        CHKCON:   MVI   C,11   ;check console.
DDC4   CD 05 80               CALL   ENTRY   
DDC7   B7                     ORA   A   
DDC8   C8                     RZ      ;return if nothing.
DDC9   0E 01                  MVI   C,1   ;else get character.
DDCB   CD 05 80               CALL   ENTRY   
DDCE   B7                     ORA   A   ;clear zero flag and return.
DDCF   C9                     RET      
DDD0                             ; 
DDD0                             ;   Routine to get the currently active drive number.
DDD0                             ; 
DDD0   0E 19        GETDSK:   MVI   C,25   
DDD2   C3 05 80               JMP   ENTRY   
DDD5                             ; 
DDD5                             ;   Set the stabdard dma address.
DDD5                             ; 
DDD5   11 80 80     STDDMA:   LXI   D,TBUFF   
DDD8                             ; 
DDD8                             ;   Routine to set the dma address to (DE).
DDD8                             ; 
DDD8   0E 1A        DMASET:   MVI   C,26   
DDDA   C3 05 80               JMP   ENTRY   
DDDD                             ; 
DDDD                             ;  Delete the batch file created by SUBMIT.
DDDD                             ; 
DDDD   21 AB E3     DELBATCH:   LXI   H,BATCH   ;is batch active?
DDE0   7E                     MOV   A,M   
DDE1   B7                     ORA   A   
DDE2   C8                     RZ      
DDE3   36 00                  MVI   M,0   ;yes, de-activate it.
DDE5   AF                     XRA   A   
DDE6   CD BD DC               CALL   DSKSEL   ;select drive 0 for sure.
DDE9   11 AC E3               LXI   D,BATCHFCB   ;and delete this file.
DDEC   CD EF DC               CALL   DELETE   
DDEF   3A EF E3               LDA   CDRIVE   ;reset current drive.
DDF2   C3 BD DC               JMP   DSKSEL   
DDF5                             ; 
DDF5                             ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
DDF5                             ; the same or we halt....
DDF5                             ; 
DDF5   11 28 DF     VERIFY:   LXI   D,PATTRN1   ;these are the serial number bytes.
DDF8   21 F3 E3               LXI   H,PATTRN2   ;ditto, but how could they be different?
DDFB   06 06                  MVI   B,6   ;6 bytes each.
DDFD   1A           VERIFY1:   LDAX   D   
DDFE   BE                     CMP   M   
DDFF   C2 CF DF               JNZ   HALT   ;jump to halt routine.
DE02   13                     INX   D   
DE03   23                     INX   H   
DE04   05                     DCR   B   
DE05   C2 FD DD               JNZ   VERIFY1   
DE08   C9                     RET      
DE09                             ; 
DE09                             ;   Print back file name with a "?" to indicate a syntax error.
DE09                             ; 
DE09   CD 98 DC     SYNERR:   CALL   CRLF   ;end current line.
DE0C   2A 8A DC               LHLD   NAMEPNT   ;this points to name in error.
DE0F   7E           SYNERR1:   MOV   A,M   ;print it until a space or null is found.
DE10   FE 20                  CPI   " "   
DE12   CA 22 DE               JZ   SYNERR2   
DE15   B7                     ORA   A   
DE16   CA 22 DE               JZ   SYNERR2   
DE19   E5                     PUSH   H   
DE1A   CD 8C DC               CALL   PRINT   
DE1D   E1                     POP   H   
DE1E   23                     INX   H   
DE1F   C3 0F DE               JMP   SYNERR1   
DE22   3E 3F        SYNERR2:   MVI   A,"?"   ;add trailing "?".
DE24   CD 8C DC               CALL   PRINT   
DE27   CD 98 DC               CALL   CRLF   
DE2A   CD DD DD               CALL   DELBATCH   ;delete any batch file.
DE2D   C3 82 DF               JMP   CMMND1   ;and restart from console input.
DE30                             ; 
DE30                             ;   Check character at (DE) for legal command input. Note that the
DE30                             ; zero flag is set if the character is a delimiter.
DE30                             ; 
DE30   1A           CHECK:    LDAX   D   
DE31   B7                     ORA   A   
DE32   C8                     RZ      
DE33   FE 20                  CPI   " "   ;control characters are not legal here.
DE35   DA 09 DE               JC   SYNERR   
DE38   C8                     RZ      ;check for valid delimiter.
DE39   FE 3D                  CPI   "="   
DE3B   C8                     RZ      
DE3C   FE 5F                  CPI   "_"   
DE3E   C8                     RZ      
DE3F   FE 2E                  CPI   "."   
DE41   C8                     RZ      
DE42   FE 3A                  CPI   ":"   
DE44   C8                     RZ      
DE45   FE 3B                  CPI   ";"   
DE47   C8                     RZ      
DE48   FE 3C                  CPI   "<"   
DE4A   C8                     RZ      
DE4B   FE 3E                  CPI   ">"   
DE4D   C8                     RZ      
DE4E   C9                     RET      
DE4F                             ; 
DE4F                             ;   Get the next non-blank character from (DE).
DE4F                             ; 
DE4F   1A           NONBLANK:   LDAX   D   
DE50   B7                     ORA   A   ;string ends with a null.
DE51   C8                     RZ      
DE52   FE 20                  CPI   " "   
DE54   C0                     RNZ      
DE55   13                     INX   D   
DE56   C3 4F DE               JMP   NONBLANK   
DE59                             ; 
DE59                             ;   Add (HL)=(HL)+(A)
DE59                             ; 
DE59   85           ADDHL:    ADD   L   
DE5A   6F                     MOV   L,A   
DE5B   D0                     RNC      ;take care of any carry.
DE5C   24                     INR   H   
DE5D   C9                     RET      
DE5E                             ; 
DE5E                             ;   Convert the first name in (FCB).
DE5E                             ; 
DE5E   3E 00        CONVFST:   MVI   A,0   
DE60                             ; 
DE60                             ;   Format a file name (convert * to "?", etc.). On return,
DE60                             ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
DE60                             ; the position within the fcb for the name (either 0 or 16).
DE60                             ; 
DE60   21 5C 80     CONVERT:   LXI   H,TFCB   
DE63   CD 59 DE               CALL   ADDHL   
DE66   E5                     PUSH   H   
DE67   E5                     PUSH   H   
DE68   AF                     XRA   A   
DE69   32 F0 E3               STA   CHGDRV   ;initialize drive change flag.
DE6C   2A 88 DC               LHLD   INPOINT   ;set (HL) as pointer into input line.
DE6F   EB                     XCHG      
DE70   CD 4F DE               CALL   NONBLANK   ;get next non-blank character.
DE73   EB                     XCHG      
DE74   22 8A DC               SHLD   NAMEPNT   ;save pointer here for any error message.
DE77   EB                     XCHG      
DE78   E1                     POP   H   
DE79   1A                     LDAX   D   ;get first character.
DE7A   B7                     ORA   A   
DE7B   CA 89 DE               JZ   CONVRT1   
DE7E   DE 40                  SBI   "A"-1   ;might be a drive name, convert to binary.
DE80   47                     MOV   B,A   ;and save.
DE81   13                     INX   D   ;check next character for a ":".
DE82   1A                     LDAX   D   
DE83   FE 3A                  CPI   ":"   
DE85   CA 90 DE               JZ   CONVRT2   
DE88   1B                     DCX   D   ;nope, move pointer back to the start of the line.
DE89   3A EF E3     CONVRT1:   LDA   CDRIVE   
DE8C   77                     MOV   M,A   
DE8D   C3 96 DE               JMP   CONVRT3   
DE90   78           CONVRT2:   MOV   A,B   
DE91   32 F0 E3               STA   CHGDRV   ;set change in drives flag.
DE94   70                     MOV   M,B   
DE95   13                     INX   D   
DE96                             ; 
DE96                             ;   Convert the basic file name.
DE96                             ; 
DE96   06 08        CONVRT3:   MVI   B,08H   
DE98   CD 30 DE     CONVRT4:   CALL   CHECK   
DE9B   CA B9 DE               JZ   CONVRT8   
DE9E   23                     INX   H   
DE9F   FE 2A                  CPI   "*"   ;note that an "*" will fill the remaining
DEA1   C2 A9 DE               JNZ   CONVRT5   ;field with "?".
DEA4   36 3F                  MVI   M,"?"   
DEA6   C3 AB DE               JMP   CONVRT6   
DEA9   77           CONVRT5:   MOV   M,A   
DEAA   13                     INX   D   
DEAB   05           CONVRT6:   DCR   B   
DEAC   C2 98 DE               JNZ   CONVRT4   
DEAF   CD 30 DE     CONVRT7:   CALL   CHECK   ;get next delimiter.
DEB2   CA C0 DE               JZ   GETEXT   
DEB5   13                     INX   D   
DEB6   C3 AF DE               JMP   CONVRT7   
DEB9   23           CONVRT8:   INX   H   ;blank fill the file name.
DEBA   36 20                  MVI   M," "   
DEBC   05                     DCR   B   
DEBD   C2 B9 DE               JNZ   CONVRT8   
DEC0                             ; 
DEC0                             ;   Get the extension and convert it.
DEC0                             ; 
DEC0   06 03        GETEXT:   MVI   B,03H   
DEC2   FE 2E                  CPI   "."   
DEC4   C2 E9 DE               JNZ   GETEXT5   
DEC7   13                     INX   D   
DEC8   CD 30 DE     GETEXT1:   CALL   CHECK   
DECB   CA E9 DE               JZ   GETEXT5   
DECE   23                     INX   H   
DECF   FE 2A                  CPI   "*"   
DED1   C2 D9 DE               JNZ   GETEXT2   
DED4   36 3F                  MVI   M,"?"   
DED6   C3 DB DE               JMP   GETEXT3   
DED9   77           GETEXT2:   MOV   M,A   
DEDA   13                     INX   D   
DEDB   05           GETEXT3:   DCR   B   
DEDC   C2 C8 DE               JNZ   GETEXT1   
DEDF   CD 30 DE     GETEXT4:   CALL   CHECK   
DEE2   CA F0 DE               JZ   GETEXT6   
DEE5   13                     INX   D   
DEE6   C3 DF DE               JMP   GETEXT4   
DEE9   23           GETEXT5:   INX   H   
DEEA   36 20                  MVI   M," "   
DEEC   05                     DCR   B   
DEED   C2 E9 DE               JNZ   GETEXT5   
DEF0   06 03        GETEXT6:   MVI   B,3   
DEF2   23           GETEXT7:   INX   H   
DEF3   36 00                  MVI   M,0   
DEF5   05                     DCR   B   
DEF6   C2 F2 DE               JNZ   GETEXT7   
DEF9   EB                     XCHG      
DEFA   22 88 DC               SHLD   INPOINT   ;save input line pointer.
DEFD   E1                     POP   H   
DEFE                             ; 
DEFE                             ;   Check to see if this is an ambigeous file name specification.
DEFE                             ; Set the (A) register to non zero if it is.
DEFE                             ; 
DEFE   01 0B 00               LXI   B,11   ;set name length.
DF01   23           GETEXT8:   INX   H   
DF02   7E                     MOV   A,M   
DF03   FE 3F                  CPI   "?"   ;any question marks?
DF05   C2 09 DF               JNZ   GETEXT9   
DF08   04                     INR   B   ;count them.
DF09   0D           GETEXT9:   DCR   C   
DF0A   C2 01 DF               JNZ   GETEXT8   
DF0D   78                     MOV   A,B   
DF0E   B7                     ORA   A   
DF0F   C9                     RET      
DF10                             ; 
DF10                             ;   CP/M command table. Note commands can be either 3 or 4 characters long.
DF10                             ; 
DF10                NUMCMDS:   EQU   6   ;number of commands
DF10   44 49 52 20  CMDTBL:   DB   "DIR "   
DF14   45 52 41 20            DB   "ERA "   
DF18   54 59 50 45            DB   "TYPE"   
DF1C   53 41 56 45            DB   "SAVE"   
DF20   52 45 4E 20            DB   "REN "   
DF24   55 53 45 52            DB   "USER"   
DF28                             ; 
DF28                             ;   The following six bytes must agree with those at (PATTRN2)
DF28                             ; or cp/m will HALT. Why?
DF28                             ; 
DF28   00 16 00 00 00 00 PATTRN1:   DB   0,22,0,0,0,0   ;(* serial number bytes *).
DF2E                             ; 
DF2E                             ;   Search the command table for a match with what has just
DF2E                             ; been entered. If a match is found, then we jump to the
DF2E                             ; proper section. Else jump to (UNKNOWN).
DF2E                             ; On return, the (C) register is set to the command number
DF2E                             ; that matched (or NUMCMDS+1 if no match).
DF2E                             ; 
DF2E   21 10 DF     SEARCH:   LXI   H,CMDTBL   
DF31   0E 00                  MVI   C,0   
DF33   79           SEARCH1:   MOV   A,C   
DF34   FE 06                  CPI   NUMCMDS   ;this commands exists.
DF36   D0                     RNC      
DF37   11 5D 80               LXI   D,TFCB+1   ;check this one.
DF3A   06 04                  MVI   B,4   ;max command length.
DF3C   1A           SEARCH2:   LDAX   D   
DF3D   BE                     CMP   M   
DF3E   C2 4F DF               JNZ   SEARCH3   ;not a match.
DF41   13                     INX   D   
DF42   23                     INX   H   
DF43   05                     DCR   B   
DF44   C2 3C DF               JNZ   SEARCH2   
DF47   1A                     LDAX   D   ;allow a 3 character command to match.
DF48   FE 20                  CPI   " "   
DF4A   C2 54 DF               JNZ   SEARCH4   
DF4D   79                     MOV   A,C   ;set return register for this command.
DF4E   C9                     RET      
DF4F   23           SEARCH3:   INX   H   
DF50   05                     DCR   B   
DF51   C2 4F DF               JNZ   SEARCH3   
DF54   0C           SEARCH4:   INR   C   
DF55   C3 33 DF               JMP   SEARCH1   
DF58                             ; 
DF58                             ;   Set the input buffer to empty and then start the command
DF58                             ; processor (ccp).
DF58                             ; 
DF58   AF           CLEARBUF:   XRA   A   
DF59   32 07 DC               STA   INBUFF+1   ;second byte is actual length.
DF5C                             ; 
DF5C                             ;**************************************************************
DF5C                             ;*
DF5C                             ;*
DF5C                             ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
DF5C                             ;*
DF5C                             ;**************************************************************
DF5C                             ;*
DF5C   31 AB E3     COMMAND:   LXI   SP,CCPSTACK   ;setup stack area.
DF5F   C5                     PUSH   B   ;note that (C) should be equal to:
DF60   79                     MOV   A,C   ;(uuuudddd) where "uuuu" is the user number
DF61   1F                     RAR      ;and "dddd" is the drive number.
DF62   1F                     RAR      
DF63   1F                     RAR      
DF64   1F                     RAR      
DF65   E6 0F                  ANI   0FH   ;isolate the user number.
DF67   5F                     MOV   E,A   
DF68   CD 15 DD               CALL   GETSETUC   ;and set it.
DF6B   CD B8 DC               CALL   RESDSK   ;reset the disk system.
DF6E   32 AB E3               STA   BATCH   ;clear batch mode flag.
DF71   C1                     POP   B   
DF72   79                     MOV   A,C   
DF73   E6 0F                  ANI   0FH   ;isolate the drive number.
DF75   32 EF E3               STA   CDRIVE   ;and save.
DF78   CD BD DC               CALL   DSKSEL   ;...and select.
DF7B   3A 07 DC               LDA   INBUFF+1   
DF7E   B7                     ORA   A   ;anything in input buffer already?
DF7F   C2 98 DF               JNZ   CMMND2   ;yes, we just process it.
DF82                             ; 
DF82                             ;   Entry point to get a command line from the console.
DF82                             ; 
DF82   31 AB E3     CMMND1:   LXI   SP,CCPSTACK   ;set stack straight.
DF85   CD 98 DC               CALL   CRLF   ;start a new line on the screen.
DF88   CD D0 DD               CALL   GETDSK   ;get current drive.
DF8B   C6 61                  ADI   "a"   
DF8D   CD 8C DC               CALL   PRINT   ;print current drive.
DF90   3E 3E                  MVI   A,">"   
DF92   CD 8C DC               CALL   PRINT   ;and add prompt.
DF95   CD 39 DD               CALL   GETINP   ;get line from user.
DF98                             ; 
DF98                             ;   Process command line here.
DF98                             ; 
DF98   11 80 80     CMMND2:   LXI   D,TBUFF   
DF9B   CD D8 DD               CALL   DMASET   ;set standard dma address.
DF9E   CD D0 DD               CALL   GETDSK   
DFA1   32 EF E3               STA   CDRIVE   ;set current drive.
DFA4   CD 5E DE               CALL   CONVFST   ;convert name typed in.
DFA7   C4 09 DE               CNZ   SYNERR   ;wild cards are not allowed.
DFAA   3A F0 E3               LDA   CHGDRV   ;if a change in drives was indicated,
DFAD   B7                     ORA   A   ;then treat this as an unknown command
DFAE   C2 A5 E2               JNZ   UNKNOWN   ;which gets executed.
DFB1   CD 2E DF               CALL   SEARCH   ;else search command table for a match.
DFB4                             ; 
DFB4                             ;   Note that an unknown command returns
DFB4                             ; with (A) pointing to the last address
DFB4                             ; in our table which is (UNKNOWN).
DFB4                             ; 
DFB4   21 C1 DF               LXI   H,CMDADR   ;now, look thru our address table for command (A).
DFB7   5F                     MOV   E,A   ;set (DE) to command number.
DFB8   16 00                  MVI   D,0   
DFBA   19                     DAD   D   
DFBB   19                     DAD   D   ;(HL)=(CMDADR)+2*(command number).
DFBC   7E                     MOV   A,M   ;now pick out this address.
DFBD   23                     INX   H   
DFBE   66                     MOV   H,M   
DFBF   6F                     MOV   L,A   
DFC0   E9                     PCHL      ;now execute it.
DFC1                             ; 
DFC1                             ;   CP/M command address table.
DFC1                             ; 
DFC1   77 E0 1F E1 5D E1 AD E1 CMDADR:   DW   DIRECT,ERASE,TYPE,SAVE   
DFC9   10 E2 8E E2 A5 E2      DW   RENAME,USER,UNKNOWN   
DFCF                             ; 
DFCF                             ;   Halt the system. Reason for this is unknown at present.
DFCF                             ; 
DFCF   21 F3 76     HALT:     LXI   H,76F3H   ;"DI HLT" instructions.
DFD2   22 00 DC               SHLD   CBASE   
DFD5   21 00 DC               LXI   H,CBASE   
DFD8   E9                     PCHL      
DFD9                             ; 
DFD9                             ;   Read error while TYPEing a file.
DFD9                             ; 
DFD9   01 DF DF     RDERROR:   LXI   B,RDERR   
DFDC   C3 A7 DC               JMP   PLINE   
DFDF   52 65 61 64 20 65 72 72 6F 72 00 RDERR:   DB   "Read error",0   
DFEA                             ; 
DFEA                             ;   Required file was not located.
DFEA                             ; 
DFEA   01 F0 DF     NONE:     LXI   B,NOFILE   
DFED   C3 A7 DC               JMP   PLINE   
DFF0   4E 6F 20 66 69 6C 65 00 NOFILE:   DB   "No file",0   
DFF8                             ; 
DFF8                             ;   Decode a command of the form 'A>filename number00bbIGZpbGVuYW1l.
DFF8                             ; Note that a drive specifier is not allowed on the first file
DFF8                             ; name. On return, the number is in register (A). Any error
DFF8                             ; causes "filename?" to be printed and the command is aborted.
DFF8                             ; 
DFF8   CD 5E DE     DECODE:   CALL   CONVFST   ;convert filename.
DFFB   3A F0 E3               LDA   CHGDRV   ;do not allow a drive to be specified.
DFFE   B7                     ORA   A   
DFFF   C2 09 DE               JNZ   SYNERR   
E002   21 5D 80               LXI   H,TFCB+1   ;convert number now.
E005   01 0B 00               LXI   B,11   ;(B)=sum register, (C)=max digit count.
E008   7E           DECODE1:   MOV   A,M   
E009   FE 20                  CPI   " "   ;a space terminates the numeral.
E00B   CA 33 E0               JZ   DECODE3   
E00E   23                     INX   H   
E00F   D6 30                  SUI   "0"   ;make binary from ascii.
E011   FE 0A                  CPI   10   ;legal digit?
E013   D2 09 DE               JNC   SYNERR   
E016   57                     MOV   D,A   ;yes, save it in (D).
E017   78                     MOV   A,B   ;compute (B)=(B)*10 and check for overflow.
E018   E6 E0                  ANI   0E0H   
E01A   C2 09 DE               JNZ   SYNERR   
E01D   78                     MOV   A,B   
E01E   07                     RLC      
E01F   07                     RLC      
E020   07                     RLC      ;(A)=(B)*8
E021   80                     ADD   B   ;.......*9
E022   DA 09 DE               JC   SYNERR   
E025   80                     ADD   B   ;.......*10
E026   DA 09 DE               JC   SYNERR   
E029   82                     ADD   D   ;add in new digit now.
E02A   DA 09 DE     DECODE2:   JC   SYNERR   
E02D   47                     MOV   B,A   ;and save result.
E02E   0D                     DCR   C   ;only look at 11 digits.
E02F   C2 08 E0               JNZ   DECODE1   
E032   C9                     RET      
E033   7E           DECODE3:   MOV   A,M   ;spaces must follow (why?).
E034   FE 20                  CPI   " "   
E036   C2 09 DE               JNZ   SYNERR   
E039   23                     INX   H   
E03A   0D           DECODE4:   DCR   C   
E03B   C2 33 E0               JNZ   DECODE3   
E03E   78                     MOV   A,B   ;set (A)=the numeric value entered.
E03F   C9                     RET      
E040                             ; 
E040                             ;   Move 3 bytes from (HL) to (DE). Note that there is only
E040                             ; one reference to this at (A2D5h).
E040                             ; 
E040   06 03        MOVE3:    MVI   B,3   
E042                             ; 
E042                             ;   Move (B) bytes from (HL) to (DE).
E042                             ; 
E042   7E           HL2DE:    MOV   A,M   
E043   12                     STAX   D   
E044   23                     INX   H   
E045   13                     INX   D   
E046   05                     DCR   B   
E047   C2 42 E0               JNZ   HL2DE   
E04A   C9                     RET      
E04B                             ; 
E04B                             ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
E04B                             ; 
E04B   21 80 80     EXTRACT:   LXI   H,TBUFF   
E04E   81                     ADD   C   
E04F   CD 59 DE               CALL   ADDHL   
E052   7E                     MOV   A,M   
E053   C9                     RET      
E054                             ; 
E054                             ;  Check drive specified. If it means a change, then the new
E054                             ; drive will be selected. In any case, the drive byte of the
E054                             ; fcb will be set to null (means use current drive).
E054                             ; 
E054   AF           DSELECT:   XRA   A   ;null out first byte of fcb.
E055   32 5C 80               STA   TFCB   
E058   3A F0 E3               LDA   CHGDRV   ;a drive change indicated?
E05B   B7                     ORA   A   
E05C   C8                     RZ      
E05D   3D                     DCR   A   ;yes, is it the same as the current drive?
E05E   21 EF E3               LXI   H,CDRIVE   
E061   BE                     CMP   M   
E062   C8                     RZ      
E063   C3 BD DC               JMP   DSKSEL   ;no. Select it then.
E066                             ; 
E066                             ;   Check the drive selection and reset it to the previous
E066                             ; drive if it was changed for the preceeding command.
E066                             ; 
E066   3A F0 E3     RESETDR:   LDA   CHGDRV   ;drive change indicated?
E069   B7                     ORA   A   
E06A   C8                     RZ      
E06B   3D                     DCR   A   ;yes, was it a different drive?
E06C   21 EF E3               LXI   H,CDRIVE   
E06F   BE                     CMP   M   
E070   C8                     RZ      
E071   3A EF E3               LDA   CDRIVE   ;yes, re-select our old drive.
E074   C3 BD DC               JMP   DSKSEL   
E077                             ; 
E077                             ;**************************************************************
E077                             ;*
E077                             ;*           D I R E C T O R Y   C O M M A N D
E077                             ;*
E077                             ;**************************************************************
E077                             ; 
E077   CD 5E DE     DIRECT:   CALL   CONVFST   ;convert file name.
E07A   CD 54 E0               CALL   DSELECT   ;select indicated drive.
E07D   21 5D 80               LXI   H,TFCB+1   ;was any file indicated?
E080   7E                     MOV   A,M   
E081   FE 20                  CPI   " "   
E083   C2 8F E0               JNZ   DIRECT2   
E086   06 0B                  MVI   B,11   ;no. Fill field with "?" - same as *.*.
E088   36 3F        DIRECT1:   MVI   M,"?"   
E08A   23                     INX   H   
E08B   05                     DCR   B   
E08C   C2 88 E0               JNZ   DIRECT1   
E08F   1E 00        DIRECT2:   MVI   E,0   ;set initial cursor position.
E091   D5                     PUSH   D   
E092   CD E9 DC               CALL   SRCHFCB   ;get first file name.
E095   CC EA DF               CZ   NONE   ;none found at all?
E098   CA 1B E1     DIRECT3:   JZ   DIRECT9   ;terminate if no more names.
E09B   3A EE E3               LDA   RTNCODE   ;get file's position in segment (0-3).
E09E   0F                     RRC      
E09F   0F                     RRC      
E0A0   0F                     RRC      
E0A1   E6 60                  ANI   60H   ;(A)=position*32
E0A3   4F                     MOV   C,A   
E0A4   3E 0A                  MVI   A,10   
E0A6   CD 4B E0               CALL   EXTRACT   ;extract the tenth entry in fcb.
E0A9   17                     RAL      ;check system file status bit.
E0AA   DA 0F E1               JC   DIRECT8   ;we don't list them.
E0AD   D1                     POP   D   
E0AE   7B                     MOV   A,E   ;bump name count.
E0AF   1C                     INR   E   
E0B0   D5                     PUSH   D   
E0B1   E6 03                  ANI   03H   ;at end of line?
E0B3   F5                     PUSH   PSW   
E0B4   C2 CC E0               JNZ   DIRECT4   
E0B7   CD 98 DC               CALL   CRLF   ;yes, end this line and start another.
E0BA   C5                     PUSH   B   
E0BB   CD D0 DD               CALL   GETDSK   ;start line with ("A:").
E0BE   C1                     POP   B   
E0BF   C6 41                  ADI   "A"   
E0C1   CD 92 DC               CALL   PRINTB   
E0C4   3E 3A                  MVI   A,":"   
E0C6   CD 92 DC               CALL   PRINTB   
E0C9   C3 D4 E0               JMP   DIRECT5   
E0CC   CD A2 DC     DIRECT4:   CALL   SPACE   ;add seperator between file names.
E0CF   3E 3A                  MVI   A,":"   
E0D1   CD 92 DC               CALL   PRINTB   
E0D4   CD A2 DC     DIRECT5:   CALL   SPACE   
E0D7   06 01                  MVI   B,1   ;"extract" each file name character at a time.
E0D9   78           DIRECT6:   MOV   A,B   
E0DA   CD 4B E0               CALL   EXTRACT   
E0DD   E6 7F                  ANI   7FH   ;strip bit 7 (status bit).
E0DF   FE 20                  CPI   " "   ;are we at the end of the name?
E0E1   C2 F9 E0               JNZ   DRECT65   
E0E4   F1                     POP   PSW   ;yes, don't print spaces at the end of a line.
E0E5   F5                     PUSH   PSW   
E0E6   FE 03                  CPI   3   
E0E8   C2 F7 E0               JNZ   DRECT63   
E0EB   3E 09                  MVI   A,9   ;first check for no extension.
E0ED   CD 4B E0               CALL   EXTRACT   
E0F0   E6 7F                  ANI   7FH   
E0F2   FE 20                  CPI   " "   
E0F4   CA 0E E1               JZ   DIRECT7   ;don't print spaces.
E0F7   3E 20        DRECT63:   MVI   A," "   ;else print them.
E0F9   CD 92 DC     DRECT65:   CALL   PRINTB   
E0FC   04                     INR   B   ;bump to next character psoition.
E0FD   78                     MOV   A,B   
E0FE   FE 0C                  CPI   12   ;end of the name?
E100   D2 0E E1               JNC   DIRECT7   
E103   FE 09                  CPI   9   ;nope, starting extension?
E105   C2 D9 E0               JNZ   DIRECT6   
E108   CD A2 DC               CALL   SPACE   ;yes, add seperating space.
E10B   C3 D9 E0               JMP   DIRECT6   
E10E   F1           DIRECT7:   POP   PSW   ;get the next file name.
E10F   CD C2 DD     DIRECT8:   CALL   CHKCON   ;first check console, quit on anything.
E112   C2 1B E1               JNZ   DIRECT9   
E115   CD E4 DC               CALL   SRCHNXT   ;get next name.
E118   C3 98 E0               JMP   DIRECT3   ;and continue with our list.
E11B   D1           DIRECT9:   POP   D   ;restore the stack and return to command level.
E11C   C3 86 E3               JMP   GETBACK   
E11F                             ; 
E11F                             ;**************************************************************
E11F                             ;*
E11F                             ;*                E R A S E   C O M M A N D
E11F                             ;*
E11F                             ;**************************************************************
E11F                             ; 
E11F   CD 5E DE     ERASE:    CALL   CONVFST   ;convert file name.
E122   FE 0B                  CPI   11   ;was "*.*" entered?
E124   C2 42 E1               JNZ   ERASE1   
E127   01 52 E1               LXI   B,YESNO   ;yes, ask for confirmation.
E12A   CD A7 DC               CALL   PLINE   
E12D   CD 39 DD               CALL   GETINP   
E130   21 07 DC               LXI   H,INBUFF+1   
E133   35                     DCR   M   ;must be exactly "y".
E134   C2 82 DF               JNZ   CMMND1   
E137   23                     INX   H   
E138   7E                     MOV   A,M   
E139   FE 59                  CPI   "Y"   
E13B   C2 82 DF               JNZ   CMMND1   
E13E   23                     INX   H   
E13F   22 88 DC               SHLD   INPOINT   ;save input line pointer.
E142   CD 54 E0     ERASE1:   CALL   DSELECT   ;select desired disk.
E145   11 5C 80               LXI   D,TFCB   
E148   CD EF DC               CALL   DELETE   ;delete the file.
E14B   3C                     INR   A   
E14C   CC EA DF               CZ   NONE   ;not there?
E14F   C3 86 E3               JMP   GETBACK   ;return to command level now.
E152   41 6C 6C 20 28 79 2F 6E 29 3F 00 YESNO:   DB   "All (y/n)?",0   
E15D                             ; 
E15D                             ;**************************************************************
E15D                             ;*
E15D                             ;*            T Y P E   C O M M A N D
E15D                             ;*
E15D                             ;**************************************************************
E15D                             ; 
E15D   CD 5E DE     TYPE:     CALL   CONVFST   ;convert file name.
E160   C2 09 DE               JNZ   SYNERR   ;wild cards not allowed.
E163   CD 54 E0               CALL   DSELECT   ;select indicated drive.
E166   CD D0 DC               CALL   OPENFCB   ;open the file.
E169   CA A7 E1               JZ   TYPE5   ;not there?
E16C   CD 98 DC               CALL   CRLF   ;ok, start a new line on the screen.
E16F   21 F1 E3               LXI   H,NBYTES   ;initialize byte counter.
E172   36 FF                  MVI   M,0FFH   ;set to read first sector.
E174   21 F1 E3     TYPE1:    LXI   H,NBYTES   
E177   7E           TYPE2:    MOV   A,M   ;have we written the entire sector?
E178   FE 80                  CPI   128   
E17A   DA 87 E1               JC   TYPE3   
E17D   E5                     PUSH   H   ;yes, read in the next one.
E17E   CD FE DC               CALL   READFCB   
E181   E1                     POP   H   
E182   C2 A0 E1               JNZ   TYPE4   ;end or error?
E185   AF                     XRA   A   ;ok, clear byte counter.
E186   77                     MOV   M,A   
E187   34           TYPE3:    INR   M   ;count this byte.
E188   21 80 80               LXI   H,TBUFF   ;and get the (A)th one from the buffer (TBUFF).
E18B   CD 59 DE               CALL   ADDHL   
E18E   7E                     MOV   A,M   
E18F   FE 1A                  CPI   CNTRLZ   ;end of file mark?
E191   CA 86 E3               JZ   GETBACK   
E194   CD 8C DC               CALL   PRINT   ;no, print it.
E197   CD C2 DD               CALL   CHKCON   ;check console, quit if anything ready.
E19A   C2 86 E3               JNZ   GETBACK   
E19D   C3 74 E1               JMP   TYPE1   
E1A0                             ; 
E1A0                             ;   Get here on an end of file or read error.
E1A0                             ; 
E1A0   3D           TYPE4:    DCR   A   ;read error?
E1A1   CA 86 E3               JZ   GETBACK   
E1A4   CD D9 DF               CALL   RDERROR   ;yes, print message.
E1A7   CD 66 E0     TYPE5:    CALL   RESETDR   ;and reset proper drive
E1AA   C3 09 DE               JMP   SYNERR   ;now print file name with problem.
E1AD                             ; 
E1AD                             ;**************************************************************
E1AD                             ;*
E1AD                             ;*            S A V E   C O M M A N D
E1AD                             ;*
E1AD                             ;**************************************************************
E1AD                             ; 
E1AD   CD F8 DF     SAVE:     CALL   DECODE   ;get numeric number that follows SAVE.
E1B0   F5                     PUSH   PSW   ;save number of pages to write.
E1B1   CD 5E DE               CALL   CONVFST   ;convert file name.
E1B4   C2 09 DE               JNZ   SYNERR   ;wild cards not allowed.
E1B7   CD 54 E0               CALL   DSELECT   ;select specified drive.
E1BA   11 5C 80               LXI   D,TFCB   ;now delete this file.
E1BD   D5                     PUSH   D   
E1BE   CD EF DC               CALL   DELETE   
E1C1   D1                     POP   D   
E1C2   CD 09 DD               CALL   CREATE   ;and create it again.
E1C5   CA FB E1               JZ   SAVE3   ;can't create?
E1C8   AF                     XRA   A   ;clear record number byte.
E1C9   32 7C 80               STA   TFCB+32   
E1CC   F1                     POP   PSW   ;convert pages to sectors.
E1CD   6F                     MOV   L,A   
E1CE   26 00                  MVI   H,0   
E1D0   29                     DAD   H   ;(HL)=number of sectors to write.
E1D1   11 00 81               LXI   D,TBASE   ;and we start from here.
E1D4   7C           SAVE1:    MOV   A,H   ;done yet?
E1D5   B5                     ORA   L   
E1D6   CA F1 E1               JZ   SAVE2   
E1D9   2B                     DCX   H   ;nope, count this and compute the start
E1DA   E5                     PUSH   H   ;of the next 128 byte sector.
E1DB   21 80 00               LXI   H,128   
E1DE   19                     DAD   D   
E1DF   E5                     PUSH   H   ;save it and set the transfer address.
E1E0   CD D8 DD               CALL   DMASET   
E1E3   11 5C 80               LXI   D,TFCB   ;write out this sector now.
E1E6   CD 04 DD               CALL   WRTREC   
E1E9   D1                     POP   D   ;reset (DE) to the start of the last sector.
E1EA   E1                     POP   H   ;restore sector count.
E1EB   C2 FB E1               JNZ   SAVE3   ;write error?
E1EE   C3 D4 E1               JMP   SAVE1   
E1F1                             ; 
E1F1                             ;   Get here after writing all of the file.
E1F1                             ; 
E1F1   11 5C 80     SAVE2:    LXI   D,TFCB   ;now close the file.
E1F4   CD DA DC               CALL   CLOSE   
E1F7   3C                     INR   A   ;did it close ok?
E1F8   C2 01 E2               JNZ   SAVE4   
E1FB                             ; 
E1FB                             ;   Print out error message (no space).
E1FB                             ; 
E1FB   01 07 E2     SAVE3:    LXI   B,NOSPACE   
E1FE   CD A7 DC               CALL   PLINE   
E201   CD D5 DD     SAVE4:    CALL   STDDMA   ;reset the standard dma address.
E204   C3 86 E3               JMP   GETBACK   
E207   4E 6F 20 73 70 61 63 65 00 NOSPACE:   DB   "No space",0   
E210                             ; 
E210                             ;**************************************************************
E210                             ;*
E210                             ;*           R E N A M E   C O M M A N D
E210                             ;*
E210                             ;**************************************************************
E210                             ; 
E210   CD 5E DE     RENAME:   CALL   CONVFST   ;convert first file name.
E213   C2 09 DE               JNZ   SYNERR   ;wild cards not allowed.
E216   3A F0 E3               LDA   CHGDRV   ;remember any change in drives specified.
E219   F5                     PUSH   PSW   
E21A   CD 54 E0               CALL   DSELECT   ;and select this drive.
E21D   CD E9 DC               CALL   SRCHFCB   ;is this file present?
E220   C2 79 E2               JNZ   RENAME6   ;yes, print error message.
E223   21 5C 80               LXI   H,TFCB   ;yes, move this name into second slot.
E226   11 6C 80               LXI   D,TFCB+16   
E229   06 10                  MVI   B,16   
E22B   CD 42 E0               CALL   HL2DE   
E22E   2A 88 DC               LHLD   INPOINT   ;get input pointer.
E231   EB                     XCHG      
E232   CD 4F DE               CALL   NONBLANK   ;get next non blank character.
E235   FE 3D                  CPI   "="   ;only allow an "=" or "_" seperator.
E237   CA 3F E2               JZ   RENAME1   
E23A   FE 5F                  CPI   "_"   
E23C   C2 73 E2               JNZ   RENAME5   
E23F   EB           RENAME1:   XCHG      
E240   23                     INX   H   ;ok, skip seperator.
E241   22 88 DC               SHLD   INPOINT   ;save input line pointer.
E244   CD 5E DE               CALL   CONVFST   ;convert this second file name now.
E247   C2 73 E2               JNZ   RENAME5   ;again, no wild cards.
E24A   F1                     POP   PSW   ;if a drive was specified, then it
E24B   47                     MOV   B,A   ;must be the same as before.
E24C   21 F0 E3               LXI   H,CHGDRV   
E24F   7E                     MOV   A,M   
E250   B7                     ORA   A   
E251   CA 59 E2               JZ   RENAME2   
E254   B8                     CMP   B   
E255   70                     MOV   M,B   
E256   C2 73 E2               JNZ   RENAME5   ;they were different, error.
E259   70           RENAME2:   MOV   M,B   ;	reset as per the first file specification.
E25A   AF                     XRA   A   
E25B   32 5C 80               STA   TFCB   ;clear the drive byte of the fcb.
E25E   CD E9 DC     RENAME3:   CALL   SRCHFCB   ;and go look for second file.
E261   CA 6D E2               JZ   RENAME4   ;doesn't exist?
E264   11 5C 80               LXI   D,TFCB   
E267   CD 0E DD               CALL   RENAM   ;ok, rename the file.
E26A   C3 86 E3               JMP   GETBACK   
E26D                             ; 
E26D                             ;   Process rename errors here.
E26D                             ; 
E26D   CD EA DF     RENAME4:   CALL   NONE   ;file not there.
E270   C3 86 E3               JMP   GETBACK   
E273   CD 66 E0     RENAME5:   CALL   RESETDR   ;bad command format.
E276   C3 09 DE               JMP   SYNERR   
E279   01 82 E2     RENAME6:   LXI   B,EXISTS   ;destination file already exists.
E27C   CD A7 DC               CALL   PLINE   
E27F   C3 86 E3               JMP   GETBACK   
E282   46 69 6C 65 20 65 78 69 73 74 73 00 EXISTS:   DB   "File exists",0   
E28E                             ; 
E28E                             ;**************************************************************
E28E                             ;*
E28E                             ;*             U S E R   C O M M A N D
E28E                             ;*
E28E                             ;**************************************************************
E28E                             ; 
E28E   CD F8 DF     USER:     CALL   DECODE   ;get numeric value following command.
E291   FE 10                  CPI   16   ;legal user number?
E293   D2 09 DE               JNC   SYNERR   
E296   5F                     MOV   E,A   ;yes but is there anything else?
E297   3A 5D 80               LDA   TFCB+1   
E29A   FE 20                  CPI   " "   
E29C   CA 09 DE               JZ   SYNERR   ;yes, that is not allowed.
E29F   CD 15 DD               CALL   GETSETUC   ;ok, set user code.
E2A2   C3 89 E3               JMP   GETBACK1   
E2A5                             ; 
E2A5                             ;**************************************************************
E2A5                             ;*
E2A5                             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
E2A5                             ;*
E2A5                             ;**************************************************************
E2A5                             ; 
E2A5   CD F5 DD     UNKNOWN:   CALL   VERIFY   ;check for valid system (why?).
E2A8   3A 5D 80               LDA   TFCB+1   ;anything to execute?
E2AB   FE 20                  CPI   " "   
E2AD   C2 C4 E2               JNZ   UNKWN1   
E2B0   3A F0 E3               LDA   CHGDRV   ;nope, only a drive change?
E2B3   B7                     ORA   A   
E2B4   CA 89 E3               JZ   GETBACK1   ;neither???
E2B7   3D                     DCR   A   
E2B8   32 EF E3               STA   CDRIVE   ;ok, store new drive.
E2BB   CD 29 DD               CALL   MOVECD   ;set (TDRIVE) also.
E2BE   CD BD DC               CALL   DSKSEL   ;and select this drive.
E2C1   C3 89 E3               JMP   GETBACK1   ;then return.
E2C4                             ; 
E2C4                             ;   Here a file name was typed. Prepare to execute it.
E2C4                             ; 
E2C4   11 65 80     UNKWN1:   LXI   D,TFCB+9   ;an extension specified?
E2C7   1A                     LDAX   D   
E2C8   FE 20                  CPI   " "   
E2CA   C2 09 DE               JNZ   SYNERR   ;yes, not allowed.
E2CD   D5           UNKWN2:   PUSH   D   
E2CE   CD 54 E0               CALL   DSELECT   ;select specified drive.
E2D1   D1                     POP   D   
E2D2   21 83 E3               LXI   H,COMFILE   ;set the extension to "COM".
E2D5   CD 40 E0               CALL   MOVE3   
E2D8   CD D0 DC               CALL   OPENFCB   ;and open this file.
E2DB   CA 6B E3               JZ   UNKWN9   ;not present?
E2DE                             ; 
E2DE                             ;   Load in the program.
E2DE                             ; 
E2DE   21 00 81               LXI   H,TBASE   ;store the program starting here.
E2E1   E5           UNKWN3:   PUSH   H   
E2E2   EB                     XCHG      
E2E3   CD D8 DD               CALL   DMASET   ;set transfer address.
E2E6   11 5C 80               LXI   D,TFCB   ;and read the next record.
E2E9   CD F9 DC               CALL   RDREC   
E2EC   C2 01 E3               JNZ   UNKWN4   ;end of file or read error?
E2EF   E1                     POP   H   ;nope, bump pointer for next sector.
E2F0   11 80 00               LXI   D,128   
E2F3   19                     DAD   D   
E2F4   11 00 DC               LXI   D,CBASE   ;enough room for the whole file?
E2F7   7D                     MOV   A,L   
E2F8   93                     SUB   E   
E2F9   7C                     MOV   A,H   
E2FA   9A                     SBB   D   
E2FB   D2 71 E3               JNC   UNKWN0   ;no, it can't fit.
E2FE   C3 E1 E2               JMP   UNKWN3   
E301                             ; 
E301                             ;   Get here after finished reading.
E301                             ; 
E301   E1           UNKWN4:   POP   H   
E302   3D                     DCR   A   ;normal end of file?
E303   C2 71 E3               JNZ   UNKWN0   
E306   CD 66 E0               CALL   RESETDR   ;yes, reset previous drive.
E309   CD 5E DE               CALL   CONVFST   ;convert the first file name that follows
E30C   21 F0 E3               LXI   H,CHGDRV   ;command name.
E30F   E5                     PUSH   H   
E310   7E                     MOV   A,M   ;set drive code in default fcb.
E311   32 5C 80               STA   TFCB   
E314   3E 10                  MVI   A,16   ;put second name 16 bytes later.
E316   CD 60 DE               CALL   CONVERT   ;convert second file name.
E319   E1                     POP   H   
E31A   7E                     MOV   A,M   ;and set the drive for this second file.
E31B   32 6C 80               STA   TFCB+16   
E31E   AF                     XRA   A   ;clear record byte in fcb.
E31F   32 7C 80               STA   TFCB+32   
E322   11 5C 80               LXI   D,TFCB   ;move it into place at(005Ch).
E325   21 5C 80               LXI   H,TFCB   
E328   06 21                  MVI   B,33   
E32A   CD 42 E0               CALL   HL2DE   
E32D   21 08 DC               LXI   H,INBUFF+2   ;now move the remainder of the input
E330   7E           UNKWN5:   MOV   A,M   ;line down to (0080h). Look for a non blank.
E331   B7                     ORA   A   ;or a null.
E332   CA 3E E3               JZ   UNKWN6   
E335   FE 20                  CPI   " "   
E337   CA 3E E3               JZ   UNKWN6   
E33A   23                     INX   H   
E33B   C3 30 E3               JMP   UNKWN5   
E33E                             ; 
E33E                             ;   Do the line move now. It ends in a null byte.
E33E                             ; 
E33E   06 00        UNKWN6:   MVI   B,0   ;keep a character count.
E340   11 81 80               LXI   D,TBUFF+1   ;data gets put here.
E343   7E           UNKWN7:   MOV   A,M   ;move it now.
E344   12                     STAX   D   
E345   B7                     ORA   A   
E346   CA 4F E3               JZ   UNKWN8   
E349   04                     INR   B   
E34A   23                     INX   H   
E34B   13                     INX   D   
E34C   C3 43 E3               JMP   UNKWN7   
E34F   78           UNKWN8:   MOV   A,B   ;now store the character count.
E350   32 80 80               STA   TBUFF   
E353   CD 98 DC               CALL   CRLF   ;clean up the screen.
E356   CD D5 DD               CALL   STDDMA   ;set standard transfer address.
E359   CD 1A DD               CALL   SETCDRV   ;reset current drive.
E35C   CD 00 81               CALL   TBASE   ;and execute the program.
E35F                             ; 
E35F                             ;   Transiant programs return here (or reboot).
E35F                             ; 
E35F   31 AB E3               LXI   SP,BATCH   ;set stack first off.
E362   CD 29 DD               CALL   MOVECD   ;move current drive into place (TDRIVE).
E365   CD BD DC               CALL   DSKSEL   ;and reselect it.
E368   C3 82 DF               JMP   CMMND1   ;back to comand mode.
E36B                             ; 
E36B                             ;   Get here if some error occured.
E36B                             ; 
E36B   CD 66 E0     UNKWN9:   CALL   RESETDR   ;inproper format.
E36E   C3 09 DE               JMP   SYNERR   
E371   01 7A E3     UNKWN0:   LXI   B,BADLOAD   ;read error or won't fit.
E374   CD A7 DC               CALL   PLINE   
E377   C3 86 E3               JMP   GETBACK   
E37A   42 61 64 20 6C 6F 61 64 00 BADLOAD:   DB   "Bad load",0   
E383   43 4F 4D     COMFILE:   DB   "COM"   ;command file extension.
E386                             ; 
E386                             ;   Get here to return to command level. We will reset the
E386                             ; previous active drive and then either return to command
E386                             ; level directly or print error message and then return.
E386                             ; 
E386   CD 66 E0     GETBACK:   CALL   RESETDR   ;reset previous drive.
E389   CD 5E DE     GETBACK1:   CALL   CONVFST   ;convert first name in (FCB).
E38C   3A 5D 80               LDA   TFCB+1   ;if this was just a drive change request,
E38F   D6 20                  SUI   " "   ;make sure it was valid.
E391   21 F0 E3               LXI   H,CHGDRV   
E394   B6                     ORA   M   
E395   C2 09 DE               JNZ   SYNERR   
E398   C3 82 DF               JMP   CMMND1   ;ok, return to command level.
E39B                             ; 
E39B                             ;   ccp stack area.
E39B                             ; 
E39B   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E3AB                CCPSTACK:   EQU   $   ;end of ccp stack area.
E3AB                             ; 
E3AB                             ;   Batch (or SUBMIT) processing information storage.
E3AB                             ; 
E3AB   00           BATCH:    DB   0   ;batch mode flag (0=not active).
E3AC   00 24 24 24 20 20 20 20 20 53 55 42 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 BATCHFCB:   DB   0,"$$$     SUB",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E3CD                             ; 
E3CD                             ;   File control block setup by the CCP.
E3CD                             ; 
E3CD   00 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 TFCB:   DB   0,"           ",0,0,0,0,0,"           ",0,0,0,0,0   
E3EE   00           RTNCODE:   DB   0   ;status returned from bdos call.
E3EF   00           CDRIVE:   DB   0   ;currently active drive.
E3F0   00           CHGDRV:   DB   0   ;change in drives flag (0=no change).
E3F1   00 00        NBYTES:   DW   0   ;byte counter used by TYPE.
E3F3                             ; 
E3F3                             ;   Room for expansion?
E3F3                             ; 
E3F3                             ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
E3F3                             ; 
E3F3                             ;   Note that the following six bytes must match those at
E3F3                             ; (PATTRN1) or cp/m will HALT. Why?
E3F3                             ; 
E3F3   00 16 00 00 00 00 PATTRN2:   DB   0,22,0,0,0,0   ;(* serial number bytes *).
E3F9                             ; 
E3F9                             ;**************************************************************
E3F9                             ;*
E3F9                             ;*                    B D O S   E N T R Y
E3F9                             ;*
E3F9                             ;**************************************************************
E3F9                             ; 
E400                          .ORG   BDOS   
E400   C3 0B E4     FBASE:    JMP   FBASE1   
E403                             ; 
E403                             ;   Bdos error table.
E403                             ; 
E403   93 E4        BADSCTR:   DW   ERROR1   ;bad sector on read or write.
E405   9F E4        BADSLCT:   DW   ERROR2   ;bad disk select.
E407   A5 E4        RODISK:   DW   ERROR3   ;disk is read only.
E409   AB E4        ROFILE:   DW   ERROR4   ;file is read only.
E40B                             ; 
E40B                             ;   Entry into bdos. (DE) or (E) are the parameters passed. The
E40B                             ; function number desired is in register (C).
E40B                             ; 
E40B   EB           FBASE1:   XCHG      ;save the (DE) parameters.
E40C   22 3D E7               SHLD   PARAMS   
E40F   EB                     XCHG      
E410   7B                     MOV   A,E   ;and save register (E) in particular.
E411   32 D0 F1               STA   EPARAM   
E414   21 00 00               LXI   H,0   
E417   22 3F E7               SHLD   STATUS   ;clear return status.
E41A   39                     DAD   SP   
E41B   22 09 E7               SHLD   USRSTACK   ;save users stack pointer.
E41E   31 3B E7               LXI   SP,STKAREA   ;and set our own.
E421   AF                     XRA   A   ;clear auto select storage space.
E422   32 DA F1               STA   AUTOFLAG   
E425   32 D8 F1               STA   AUTO   
E428   21 6E F1               LXI   H,GOBACK   ;set return address.
E42B   E5                     PUSH   H   
E42C   79                     MOV   A,C   ;get function number.
E42D   FE 29                  CPI   NFUNCTS   ;valid function number?
E42F   D0                     RNC      
E430   4B                     MOV   C,E   ;keep single register function here.
E431   21 41 E4               LXI   H,FUNCTNS   ;now look thru the function table.
E434   5F                     MOV   E,A   
E435   16 00                  MVI   D,0   ;(DE)=function number.
E437   19                     DAD   D   
E438   19                     DAD   D   ;(HL)=(start of table)+2*(function number).
E439   5E                     MOV   E,M   
E43A   23                     INX   H   
E43B   56                     MOV   D,M   ;now (DE)=address for this function.
E43C   2A 3D E7               LHLD   PARAMS   ;retrieve parameters.
E43F   EB                     XCHG      ;now (DE) has the original parameters.
E440   E9                     PCHL      ;execute desired function.
E441                             ; 
E441                             ;   BDOS function jump table.
E441                             ; 
E441                NFUNCTS:   EQU   41   ;number of functions in followin table.
E441                             ; 
E441   A7 F2 C2 E6 8A E5 C8 E6 48 F3 44 F3 CE E6 E7 E6 FUNCTNS:   DW   WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB   
E451   ED E6 F2 E6 DB E5 F8 E6 78 F0 7D F0 3F F0 96 F0 DW   SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL   
E461   9F F0 A5 F0 C2 F0 D1 F0 DA F0 E0 F0 E6 F0 DW   CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE   
E46F   EF F0 F8 F0 FE F0 04 F1 0B F1 26 E9 11 F1 17 F1 DW   RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR   
E47F   20 F1 27 F1 3B F1 41 F1 47 F1 08 F0 4D F1 FE E6 DW   GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN   
E48F   FE E6 95 F1            DW   RTN,WTSPECL   
E493                             ; 
E493                             ;   Bdos error message section.
E493                             ; 
E493   21 C4 E4     ERROR1:   LXI   H,BADSEC   ;bad sector message.
E496   CD DF E4               CALL   PRTERR   ;print it and get a 1 char responce.
E499   FE 03                  CPI   CNTRLC   ;re-boot request (control-c)?
E49B   CA 00 00               JZ   0   ;yes.
E49E   C9                     RET      ;no, return to retry i/o function.
E49F                             ; 
E49F   21 CF E4     ERROR2:   LXI   H,BADSEL   ;bad drive selected.
E4A2   C3 AE E4               JMP   ERROR5   
E4A5                             ; 
E4A5   21 DB E4     ERROR3:   LXI   H,DISKRO   ;disk is read only.
E4A8   C3 AE E4               JMP   ERROR5   
E4AB                             ; 
E4AB   21 D6 E4     ERROR4:   LXI   H,FILERO   ;file is read only.
E4AE                             ; 
E4AE   CD DF E4     ERROR5:   CALL   PRTERR   
E4B1   C3 00 00               JMP   0   ;always reboot on these errors.
E4B4                             ; 
E4B4   42 64 6F 73 20 45 72 72 20 4F 6E 20 BDOSERR:   DB   "Bdos Err On "   
E4C0   20 3A 20 24  BDOSDRV:   DB   " : $"   
E4C4   42 61 64 20 53 65 63 74 6F 72 24 BADSEC:   DB   "Bad Sector$"   
E4CF   53 65 6C 65 63 74 24 BADSEL:   DB   "Select$"   
E4D6   46 69 6C 65 20 FILERO:   DB   "File "   
E4DB   52 2F 4F 24  DISKRO:   DB   "R/O$"   
E4DF                             ; 
E4DF                             ;   Print bdos error message.
E4DF                             ; 
E4DF   E5           PRTERR:   PUSH   H   ;save second message pointer.
E4E0   CD C3 E5               CALL   OUTCRLF   ;send (cr)(lf).
E4E3   3A 3C E7               LDA   ACTIVE   ;get active drive.
E4E6   C6 41                  ADI   "A"   ;make ascii.
E4E8   32 C0 E4               STA   BDOSDRV   ;and put in message.
E4EB   01 B4 E4               LXI   B,BDOSERR   ;and print it.
E4EE   CD CD E5               CALL   PRTMESG   
E4F1   C1                     POP   B   ;print second message line now.
E4F2   CD CD E5               CALL   PRTMESG   
E4F5                             ; 
E4F5                             ;   Get an input character. We will check our 1 character
E4F5                             ; buffer first. This may be set by the console status routine.
E4F5                             ; 
E4F5   21 08 E7     GETCHAR:   LXI   H,CHARBUF   ;check character buffer.
E4F8   7E                     MOV   A,M   ;anything present already?
E4F9   36 00                  MVI   M,0   ;...either case clear it.
E4FB   B7                     ORA   A   
E4FC   C0                     RNZ      ;yes, use it.
E4FD   C3 27 F3               JMP   CONIN   ;nope, go get a character responce.
E500                             ; 
E500                             ;   Input and echo a character.
E500                             ; 
E500   CD F5 E4     GETECHO:   CALL   GETCHAR   ;input a character.
E503   CD 0E E5               CALL   CHKCHAR   ;carriage control?
E506   D8                     RC      ;no, a regular control char so don't echo.
E507   F5                     PUSH   PSW   ;ok, save character now.
E508   4F                     MOV   C,A   
E509   CD 8A E5               CALL   OUTCON   ;and echo it.
E50C   F1                     POP   PSW   ;get character and return.
E50D   C9                     RET      
E50E                             ; 
E50E                             ;   Check character in (A). Set the zero flag on a carriage
E50E                             ; control character and the carry flag on any other control
E50E                             ; character.
E50E                             ; 
E50E   FE 0D        CHKCHAR:   CPI   CR   ;check for carriage return, line feed, backspace,
E510   C8                     RZ      ;or a tab.
E511   FE 0A                  CPI   LF   
E513   C8                     RZ      
E514   FE 09                  CPI   TAB   
E516   C8                     RZ      
E517   FE 08                  CPI   BS   
E519   C8                     RZ      
E51A   FE 20                  CPI   " "   ;other control char? Set carry flag.
E51C   C9                     RET      
E51D                             ; 
E51D                             ;   Check the console during output. Halt on a control-s, then
E51D                             ; reboot on a control-c. If anything else is ready, clear the
E51D                             ; zero flag and return (the calling routine may want to do
E51D                             ; something).
E51D                             ; 
E51D   3A 08 E7     CKCONSOL:   LDA   CHARBUF   ;check buffer.
E520   B7                     ORA   A   ;if anything, just return without checking.
E521   C2 3F E5               JNZ   CKCON2   
E524   CD 1A F3               CALL   CONST   ;nothing in buffer. Check console.
E527   E6 01                  ANI   01H   ;look at bit 0.
E529   C8                     RZ      ;return if nothing.
E52A   CD 27 F3               CALL   CONIN   ;ok, get it.
E52D   FE 13                  CPI   CNTRLS   ;if not control-s, return with zero cleared.
E52F   C2 3C E5               JNZ   CKCON1   
E532   CD 27 F3               CALL   CONIN   ;halt processing until another char
E535   FE 03                  CPI   CNTRLC   ;is typed. Control-c?
E537   CA 00 00               JZ   0   ;yes, reboot now.
E53A   AF                     XRA   A   ;no, just pretend nothing was ever ready.
E53B   C9                     RET      
E53C   32 08 E7     CKCON1:   STA   CHARBUF   ;save character in buffer for later processing.
E53F   3E 01        CKCON2:   MVI   A,1   ;set (A) to non zero to mean something is ready.
E541   C9                     RET      
E542                             ; 
E542                             ;   Output (C) to the screen. If the printer flip-flop flag
E542                             ; is set, we will send character to printer also. The console
E542                             ; will be checked in the process.
E542                             ; 
E542   3A 04 E7     OUTCHAR:   LDA   OUTFLAG   ;check output flag.
E545   B7                     ORA   A   ;anything and we won't generate output.
E546   C2 5C E5               JNZ   OUTCHR1   
E549   C5                     PUSH   B   
E54A   CD 1D E5               CALL   CKCONSOL   ;check console (we don't care whats there).
E54D   C1                     POP   B   
E54E   C5                     PUSH   B   
E54F   CD 35 F3               CALL   CONOUT   ;output (C) to the screen.
E552   C1                     POP   B   
E553   C5                     PUSH   B   
E554   3A 07 E7               LDA   PRTFLAG   ;check printer flip-flop flag.
E557   B7                     ORA   A   
E558   C4 44 F3               CNZ   LIST   ;print it also if non-zero.
E55B   C1                     POP   B   
E55C   79           OUTCHR1:   MOV   A,C   ;update cursors position.
E55D   21 06 E7               LXI   H,CURPOS   
E560   FE 7F                  CPI   DEL   ;rubouts don't do anything here.
E562   C8                     RZ      
E563   34                     INR   M   ;bump line pointer.
E564   FE 20                  CPI   " "   ;and return if a normal character.
E566   D0                     RNC      
E567   35                     DCR   M   ;restore and check for the start of the line.
E568   7E                     MOV   A,M   
E569   B7                     ORA   A   
E56A   C8                     RZ      ;ingnore control characters at the start of the line.
E56B   79                     MOV   A,C   
E56C   FE 08                  CPI   BS   ;is it a backspace?
E56E   C2 73 E5               JNZ   OUTCHR2   
E571   35                     DCR   M   ;yes, backup pointer.
E572   C9                     RET      
E573   FE 0A        OUTCHR2:   CPI   LF   ;is it a line feed?
E575   C0                     RNZ      ;ignore anything else.
E576   36 00                  MVI   M,0   ;reset pointer to start of line.
E578   C9                     RET      
E579                             ; 
E579                             ;   Output (A) to the screen. If it is a control character
E579                             ; (other than carriage control), use ^x format.
E579                             ; 
E579   79           SHOWIT:   MOV   A,C   
E57A   CD 0E E5               CALL   CHKCHAR   ;check character.
E57D   D2 8A E5               JNC   OUTCON   ;not a control, use normal output.
E580   F5                     PUSH   PSW   
E581   0E 5E                  MVI   C,"^"   ;for a control character, preceed it with "^".
E583   CD 42 E5               CALL   OUTCHAR   
E586   F1                     POP   PSW   
E587   F6 40                  ORI   "@"   ;and then use the letter equivelant.
E589   4F                     MOV   C,A   
E58A                             ; 
E58A                             ;   Function to output (C) to the console device and expand tabs
E58A                             ; if necessary.
E58A                             ; 
E58A   79           OUTCON:   MOV   A,C   
E58B   FE 09                  CPI   TAB   ;is it a tab?
E58D   C2 42 E5               JNZ   OUTCHAR   ;use regular output.
E590   0E 20        OUTCON1:   MVI   C," "   ;yes it is, use spaces instead.
E592   CD 42 E5               CALL   OUTCHAR   
E595   3A 06 E7               LDA   CURPOS   ;go until the cursor is at a multiple of 8
E598   E6 07                  ANI   07H   ;position.
E59A   C2 90 E5               JNZ   OUTCON1   
E59D   C9                     RET      
E59E                             ; 
E59E                             ;   Echo a backspace character. Erase the prevoius character
E59E                             ; on the screen.
E59E                             ; 
E59E   CD A6 E5     BACKUP:   CALL   BACKUP1   ;backup the screen 1 place.
E5A1   0E 20                  MVI   C," "   ;then blank that character.
E5A3   CD 35 F3               CALL   CONOUT   
E5A6   0E 08        BACKUP1:   MVI   C,BS   ;then back space once more.
E5A8   C3 35 F3               JMP   CONOUT   
E5AB                             ; 
E5AB                             ;   Signal a deleted line. Print a "#" at the end and start
E5AB                             ; over.
E5AB                             ; 
E5AB   0E 23        NEWLINE:   MVI   C,"#"   
E5AD   CD 42 E5               CALL   OUTCHAR   ;print this.
E5B0   CD C3 E5               CALL   OUTCRLF   ;start new line.
E5B3   3A 06 E7     NEWLN1:   LDA   CURPOS   ;move the cursor to the starting position.
E5B6   21 05 E7               LXI   H,STARTING   
E5B9   BE                     CMP   M   
E5BA   D0                     RNC      ;there yet?
E5BB   0E 20                  MVI   C," "   
E5BD   CD 42 E5               CALL   OUTCHAR   ;nope, keep going.
E5C0   C3 B3 E5               JMP   NEWLN1   
E5C3                             ; 
E5C3                             ;   Output a (cr) (lf) to the console device (screen).
E5C3                             ; 
E5C3   0E 0D        OUTCRLF:   MVI   C,CR   
E5C5   CD 42 E5               CALL   OUTCHAR   
E5C8   0E 0A                  MVI   C,LF   
E5CA   C3 42 E5               JMP   OUTCHAR   
E5CD                             ; 
E5CD                             ;   Print message pointed to by (BC). It will end with a "$".
E5CD                             ; 
E5CD   0A           PRTMESG:   LDAX   B   ;check for terminating character.
E5CE   FE 24                  CPI   "$"   
E5D0   C8                     RZ      
E5D1   03                     INX   B   
E5D2   C5                     PUSH   B   ;otherwise, bump pointer and print it.
E5D3   4F                     MOV   C,A   
E5D4   CD 8A E5               CALL   OUTCON   
E5D7   C1                     POP   B   
E5D8   C3 CD E5               JMP   PRTMESG   
E5DB                             ; 
E5DB                             ;   Function to execute a buffered read.
E5DB                             ; 
E5DB   3A 06 E7     RDBUFF:   LDA   CURPOS   ;use present location as starting one.
E5DE   32 05 E7               STA   STARTING   
E5E1   2A 3D E7               LHLD   PARAMS   ;get the maximum buffer space.
E5E4   4E                     MOV   C,M   
E5E5   23                     INX   H   ;point to first available space.
E5E6   E5                     PUSH   H   ;and save.
E5E7   06 00                  MVI   B,0   ;keep a character count.
E5E9   C5           RDBUF1:   PUSH   B   
E5EA   E5                     PUSH   H   
E5EB   CD F5 E4     RDBUF2:   CALL   GETCHAR   ;get the next input character.
E5EE   E6 7F                  ANI   7FH   ;strip bit 7.
E5F0   E1                     POP   H   ;reset registers.
E5F1   C1                     POP   B   
E5F2   FE 0D                  CPI   CR   ;en of the line?
E5F4   CA BB E6               JZ   RDBUF17   
E5F7   FE 0A                  CPI   LF   
E5F9   CA BB E6               JZ   RDBUF17   
E5FC   FE 08                  CPI   BS   ;how about a backspace?
E5FE   C2 10 E6               JNZ   RDBUF3   
E601   78                     MOV   A,B   ;yes, but ignore at the beginning of the line.
E602   B7                     ORA   A   
E603   CA E9 E5               JZ   RDBUF1   
E606   05                     DCR   B   ;ok, update counter.
E607   3A 06 E7               LDA   CURPOS   ;if we backspace to the start of the line,
E60A   32 04 E7               STA   OUTFLAG   ;treat as a cancel (control-x).
E60D   C3 6A E6               JMP   RDBUF10   
E610   FE 7F        RDBUF3:   CPI   DEL   ;user typed a rubout?
E612   C2 20 E6               JNZ   RDBUF4   
E615   78                     MOV   A,B   ;ignore at the start of the line.
E616   B7                     ORA   A   
E617   CA E9 E5               JZ   RDBUF1   
E61A   7E                     MOV   A,M   ;ok, echo the prevoius character.
E61B   05                     DCR   B   ;and reset pointers (counters).
E61C   2B                     DCX   H   
E61D   C3 A3 E6               JMP   RDBUF15   
E620   FE 05        RDBUF4:   CPI   CNTRLE   ;physical end of line?
E622   C2 31 E6               JNZ   RDBUF5   
E625   C5                     PUSH   B   ;yes, do it.
E626   E5                     PUSH   H   
E627   CD C3 E5               CALL   OUTCRLF   
E62A   AF                     XRA   A   ;and update starting position.
E62B   32 05 E7               STA   STARTING   
E62E   C3 EB E5               JMP   RDBUF2   
E631   FE 10        RDBUF5:   CPI   CNTRLP   ;control-p?
E633   C2 42 E6               JNZ   RDBUF6   
E636   E5                     PUSH   H   ;yes, flip the print flag filp-flop byte.
E637   21 07 E7               LXI   H,PRTFLAG   
E63A   3E 01                  MVI   A,1   ;PRTFLAG=1-PRTFLAG
E63C   96                     SUB   M   
E63D   77                     MOV   M,A   
E63E   E1                     POP   H   
E63F   C3 E9 E5               JMP   RDBUF1   
E642   FE 18        RDBUF6:   CPI   CNTRLX   ;control-x (cancel)?
E644   C2 59 E6               JNZ   RDBUF8   
E647   E1                     POP   H   
E648   3A 05 E7     RDBUF7:   LDA   STARTING   ;yes, backup the cursor to here.
E64B   21 06 E7               LXI   H,CURPOS   
E64E   BE                     CMP   M   
E64F   D2 DB E5               JNC   RDBUFF   ;done yet?
E652   35                     DCR   M   ;no, decrement pointer and output back up one space.
E653   CD 9E E5               CALL   BACKUP   
E656   C3 48 E6               JMP   RDBUF7   
E659   FE 15        RDBUF8:   CPI   CNTRLU   ;cntrol-u (cancel line)?
E65B   C2 65 E6               JNZ   RDBUF9   
E65E   CD AB E5               CALL   NEWLINE   ;start a new line.
E661   E1                     POP   H   
E662   C3 DB E5               JMP   RDBUFF   
E665   FE 12        RDBUF9:   CPI   CNTRLR   ;control-r?
E667   C2 A0 E6               JNZ   RDBUF14   
E66A   C5           RDBUF10:   PUSH   B   ;yes, start a new line and retype the old one.
E66B   CD AB E5               CALL   NEWLINE   
E66E   C1                     POP   B   
E66F   E1                     POP   H   
E670   E5                     PUSH   H   
E671   C5                     PUSH   B   
E672   78           RDBUF11:   MOV   A,B   ;done whole line yet?
E673   B7                     ORA   A   
E674   CA 84 E6               JZ   RDBUF12   
E677   23                     INX   H   ;nope, get next character.
E678   4E                     MOV   C,M   
E679   05                     DCR   B   ;count it.
E67A   C5                     PUSH   B   
E67B   E5                     PUSH   H   
E67C   CD 79 E5               CALL   SHOWIT   ;and display it.
E67F   E1                     POP   H   
E680   C1                     POP   B   
E681   C3 72 E6               JMP   RDBUF11   
E684   E5           RDBUF12:   PUSH   H   ;done with line. If we were displaying
E685   3A 04 E7               LDA   OUTFLAG   ;then update cursor position.
E688   B7                     ORA   A   
E689   CA EB E5               JZ   RDBUF2   
E68C   21 06 E7               LXI   H,CURPOS   ;because this line is shorter, we must
E68F   96                     SUB   M   ;back up the cursor (not the screen however)
E690   32 04 E7               STA   OUTFLAG   ;some number of positions.
E693   CD 9E E5     RDBUF13:   CALL   BACKUP   ;note that as long as (OUTFLAG) is non
E696   21 04 E7               LXI   H,OUTFLAG   ;zero, the screen will not be changed.
E699   35                     DCR   M   
E69A   C2 93 E6               JNZ   RDBUF13   
E69D   C3 EB E5               JMP   RDBUF2   ;now just get the next character.
E6A0                             ; 
E6A0                             ;   Just a normal character, put this in our buffer and echo.
E6A0                             ; 
E6A0   23           RDBUF14:   INX   H   
E6A1   77                     MOV   M,A   ;store character.
E6A2   04                     INR   B   ;and count it.
E6A3   C5           RDBUF15:   PUSH   B   
E6A4   E5                     PUSH   H   
E6A5   4F                     MOV   C,A   ;echo it now.
E6A6   CD 79 E5               CALL   SHOWIT   
E6A9   E1                     POP   H   
E6AA   C1                     POP   B   
E6AB   7E                     MOV   A,M   ;was it an abort request?
E6AC   FE 03                  CPI   CNTRLC   ;control-c abort?
E6AE   78                     MOV   A,B   
E6AF   C2 B7 E6               JNZ   RDBUF16   
E6B2   FE 01                  CPI   1   ;only if at start of line.
E6B4   CA 00 00               JZ   0   
E6B7   B9           RDBUF16:   CMP   C   ;nope, have we filled the buffer?
E6B8   DA E9 E5               JC   RDBUF1   
E6BB   E1           RDBUF17:   POP   H   ;yes end the line and return.
E6BC   70                     MOV   M,B   
E6BD   0E 0D                  MVI   C,CR   
E6BF   C3 42 E5               JMP   OUTCHAR   ;output (cr) and return.
E6C2                             ; 
E6C2                             ;   Function to get a character from the console device.
E6C2                             ; 
E6C2   CD 00 E5     GETCON:   CALL   GETECHO   ;get and echo.
E6C5   C3 FB E6               JMP   SETSTAT   ;save status and return.
E6C8                             ; 
E6C8                             ;   Function to get a character from the tape reader device.
E6C8                             ; 
E6C8   CD 4A F3     GETRDR:   CALL   READER   ;get a character from reader, set status and return.
E6CB   C3 FB E6               JMP   SETSTAT   
E6CE                             ; 
E6CE                             ;  Function to perform direct console i/o. If (C) contains (FF)
E6CE                             ; then this is an input request. If (C) contains (FE) then
E6CE                             ; this is a status request. Otherwise we are to output (C).
E6CE                             ; 
E6CE   79           DIRCIO:   MOV   A,C   ;test for (FF).
E6CF   3C                     INR   A   
E6D0   CA DA E6               JZ   DIRC1   
E6D3   3C                     INR   A   ;test for (FE).
E6D4   CA 1A F3               JZ   CONST   
E6D7   C3 35 F3               JMP   CONOUT   ;just output (C).
E6DA   CD 1A F3     DIRC1:    CALL   CONST   ;this is an input request.
E6DD   B7                     ORA   A   
E6DE   CA 8B F1               JZ   GOBACK1   ;not ready? Just return (directly).
E6E1   CD 27 F3               CALL   CONIN   ;yes, get character.
E6E4   C3 FB E6               JMP   SETSTAT   ;set status and return.
E6E7                             ; 
E6E7                             ;   Function to return the i/o byte.
E6E7                             ; 
E6E7   3A 03 80     GETIOB:   LDA   IOBYTE   
E6EA   C3 FB E6               JMP   SETSTAT   
E6ED                             ; 
E6ED                             ;   Function to set the i/o byte.
E6ED                             ; 
E6ED   21 03 80     SETIOB:   LXI   H,IOBYTE   
E6F0   71                     MOV   M,C   
E6F1   C9                     RET      
E6F2                             ; 
E6F2                             ;   Function to print the character string pointed to by (DE)
E6F2                             ; on the console device. The string ends with a "$".
E6F2                             ; 
E6F2   EB           PRTSTR:   XCHG      
E6F3   4D                     MOV   C,L   
E6F4   44                     MOV   B,H   ;now (BC) points to it.
E6F5   C3 CD E5               JMP   PRTMESG   
E6F8                             ; 
E6F8                             ;   Function to interigate the console device.
E6F8                             ; 
E6F8   CD 1D E5     GETCSTS:   CALL   CKCONSOL   
E6FB                             ; 
E6FB                             ;   Get here to set the status and return to the cleanup
E6FB                             ; section. Then back to the user.
E6FB                             ; 
E6FB   32 3F E7     SETSTAT:   STA   STATUS   
E6FE   C9           RTN:      RET      
E6FF                             ; 
E6FF                             ;   Set the status to 1 (read or write error code).
E6FF                             ; 
E6FF   3E 01        IOERR1:   MVI   A,1   
E701   C3 FB E6               JMP   SETSTAT   
E704                             ; 
E704   00           OUTFLAG:   DB   0   ;output flag (non zero means no output).
E705   02           STARTING:   DB   2   ;starting position for cursor.
E706   00           CURPOS:   DB   0   ;cursor position (0=start of line).
E707   00           PRTFLAG:   DB   0   ;printer flag (control-p toggle). List if non zero.
E708   00           CHARBUF:   DB   0   ;single input character buffer.
E709                             ; 
E709                             ;   Stack area for BDOS calls.
E709                             ; 
E709   00 00        USRSTACK:   DW   0   ;save users stack pointer here.
E70B                             ; 
E70B   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E723   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
E73B                STKAREA:   EQU   $   ;end of stack area.
E73B                             ; 
E73B   00           USERNO:   DB   0   ;current user number.
E73C   00           ACTIVE:   DB   0   ;currently active drive.
E73D   00 00        PARAMS:   DW   0   ;save (DE) parameters here on entry.
E73F   00 00        STATUS:   DW   0   ;status returned from bdos function.
E741                             ; 
E741                             ;   Select error occured, jump to error routine.
E741                             ; 
E741   21 05 E4     SLCTERR:   LXI   H,BADSLCT   
E744                             ; 
E744                             ;   Jump to (HL) indirectly.
E744                             ; 
E744   5E           JUMPHL:   MOV   E,M   
E745   23                     INX   H   
E746   56                     MOV   D,M   ;now (DE) contain the desired address.
E747   EB                     XCHG      
E748   E9                     PCHL      
E749                             ; 
E749                             ;   Block move. (DE) to (HL), (C) bytes total.
E749                             ; 
E749   0C           DE2HL:    INR   C   ;is count down to zero?
E74A   0D           DE2HL1:   DCR   C   
E74B   C8                     RZ      ;yes, we are done.
E74C   1A                     LDAX   D   ;no, move one more byte.
E74D   77                     MOV   M,A   
E74E   13                     INX   D   
E74F   23                     INX   H   
E750   C3 4A E7               JMP   DE2HL1   ;and repeat.
E753                             ; 
E753                             ;   Select the desired drive.
E753                             ; 
E753   3A 3C E7     SELECT:   LDA   ACTIVE   ;get active disk.
E756   4F                     MOV   C,A   
E757   CD 65 F3               CALL   SELDSK   ;select it.
E75A   7C                     MOV   A,H   ;valid drive?
E75B   B5                     ORA   L   ;valid drive?
E75C   C8                     RZ      ;return if not.
E75D                             ; 
E75D                             ;   Here, the BIOS returned the address of the parameter block
E75D                             ; in (HL). We will extract the necessary pointers and save them.
E75D                             ; 
E75D   5E                     MOV   E,M   ;yes, get address of translation table into (DE).
E75E   23                     INX   H   
E75F   56                     MOV   D,M   
E760   23                     INX   H   
E761   22 AD F1               SHLD   SCRATCH1   ;save pointers to scratch areas.
E764   23                     INX   H   
E765   23                     INX   H   
E766   22 AF F1               SHLD   SCRATCH2   ;ditto.
E769   23                     INX   H   
E76A   23                     INX   H   
E76B   22 B1 F1               SHLD   SCRATCH3   ;ditto.
E76E   23                     INX   H   
E76F   23                     INX   H   
E770   EB                     XCHG      ;now save the translation table address.
E771   22 CA F1               SHLD   XLATE   
E774   21 B3 F1               LXI   H,DIRBUF   ;put the next 8 bytes here.
E777   0E 08                  MVI   C,8   ;they consist of the directory buffer
E779   CD 49 E7               CALL   DE2HL   ;pointer, parameter block pointer,
E77C   2A B5 F1               LHLD   DISKPB   ;check and allocation vectors.
E77F   EB                     XCHG      
E780   21 BB F1               LXI   H,SECTORS   ;move parameter block into our ram.
E783   0E 0F                  MVI   C,15   ;it is 15 bytes long.
E785   CD 49 E7               CALL   DE2HL   
E788   2A C0 F1               LHLD   DSKSIZE   ;check disk size.
E78B   7C                     MOV   A,H   ;more than 256 blocks on this?
E78C   21 D7 F1               LXI   H,BIGDISK   
E78F   36 FF                  MVI   M,0FFH   ;set to samll.
E791   B7                     ORA   A   
E792   CA 97 E7               JZ   SELECT1   
E795   36 00                  MVI   M,0   ;wrong, set to large.
E797   3E FF        SELECT1:   MVI   A,0FFH   ;clear the zero flag.
E799   B7                     ORA   A   
E79A   C9                     RET      
E79B                             ; 
E79B                             ;   Routine to home the disk track head and clear pointers.
E79B                             ; 
E79B   CD 4F F3     HOMEDRV:   CALL   HOME   ;home the head.
E79E   AF                     XRA   A   
E79F   2A AF F1               LHLD   SCRATCH2   ;set our track pointer also.
E7A2   77                     MOV   M,A   
E7A3   23                     INX   H   
E7A4   77                     MOV   M,A   
E7A5   2A B1 F1               LHLD   SCRATCH3   ;and our sector pointer.
E7A8   77                     MOV   M,A   
E7A9   23                     INX   H   
E7AA   77                     MOV   M,A   
E7AB   C9                     RET      
E7AC                             ; 
E7AC                             ;   Do the actual disk read and check the error return status.
E7AC                             ; 
E7AC   CD C9 F3     DOREAD:   CALL   READ   
E7AF   C3 B5 E7               JMP   IORET   
E7B2                             ; 
E7B2                             ;   Do the actual disk write and handle any bios error.
E7B2                             ; 
E7B2   CD 21 F4     DOWRITE:   CALL   WRITE   
E7B5   B7           IORET:    ORA   A   
E7B6   C8                     RZ      ;return unless an error occured.
E7B7   21 03 E4               LXI   H,BADSCTR   ;bad read/write on this sector.
E7BA   C3 44 E7               JMP   JUMPHL   
E7BD                             ; 
E7BD                             ;   Routine to select the track and sector that the desired
E7BD                             ; block number falls in.
E7BD                             ; 
E7BD   2A E4 F1     TRKSEC:   LHLD   FILEPOS   ;get position of last accessed file
E7C0   0E 02                  MVI   C,2   ;in directory and compute sector #.
E7C2   CD E4 E8               CALL   SHIFTR   ;sector #=file-position/4.
E7C5   22 DF F1               SHLD   BLKNMBR   ;save this as the block number of interest.
E7C8   22 E6 F1               SHLD   CKSUMTBL   ;what's it doing here too?
E7CB                             ; 
E7CB                             ;   if the sector number has already been set (BLKNMBR), enter
E7CB                             ; at this point.
E7CB                             ; 
E7CB   21 DF F1     TRKSEC1:   LXI   H,BLKNMBR   
E7CE   4E                     MOV   C,M   ;move sector number into (BC).
E7CF   23                     INX   H   
E7D0   46                     MOV   B,M   
E7D1   2A B1 F1               LHLD   SCRATCH3   ;get current sector number and
E7D4   5E                     MOV   E,M   ;move this into (DE).
E7D5   23                     INX   H   
E7D6   56                     MOV   D,M   
E7D7   2A AF F1               LHLD   SCRATCH2   ;get current track number.
E7DA   7E                     MOV   A,M   ;and this into (HL).
E7DB   23                     INX   H   
E7DC   66                     MOV   H,M   
E7DD   6F                     MOV   L,A   
E7DE   79           TRKSEC2:   MOV   A,C   ;is desired sector before current one?
E7DF   93                     SUB   E   
E7E0   78                     MOV   A,B   
E7E1   9A                     SBB   D   
E7E2   D2 F4 E7               JNC   TRKSEC3   
E7E5   E5                     PUSH   H   ;yes, decrement sectors by one track.
E7E6   2A BB F1               LHLD   SECTORS   ;get sectors per track.
E7E9   7B                     MOV   A,E   
E7EA   95                     SUB   L   
E7EB   5F                     MOV   E,A   
E7EC   7A                     MOV   A,D   
E7ED   9C                     SBB   H   
E7EE   57                     MOV   D,A   ;now we have backed up one full track.
E7EF   E1                     POP   H   
E7F0   2B                     DCX   H   ;adjust track counter.
E7F1   C3 DE E7               JMP   TRKSEC2   
E7F4   E5           TRKSEC3:   PUSH   H   ;desired sector is after current one.
E7F5   2A BB F1               LHLD   SECTORS   ;get sectors per track.
E7F8   19                     DAD   D   ;bump sector pointer to next track.
E7F9   DA 09 E8               JC   TRKSEC4   
E7FC   79                     MOV   A,C   ;is desired sector now before current one?
E7FD   95                     SUB   L   
E7FE   78                     MOV   A,B   
E7FF   9C                     SBB   H   
E800   DA 09 E8               JC   TRKSEC4   
E803   EB                     XCHG      ;not yes, increment track counter
E804   E1                     POP   H   ;and continue until it is.
E805   23                     INX   H   
E806   C3 F4 E7               JMP   TRKSEC3   
E809                             ; 
E809                             ;   here we have determined the track number that contains the
E809                             ; desired sector.
E809                             ; 
E809   E1           TRKSEC4:   POP   H   ;get track number (HL).
E80A   C5                     PUSH   B   
E80B   D5                     PUSH   D   
E80C   E5                     PUSH   H   
E80D   EB                     XCHG      
E80E   2A C8 F1               LHLD   OFFSET   ;adjust for first track offset.
E811   19                     DAD   D   
E812   44                     MOV   B,H   
E813   4D                     MOV   C,L   
E814   CD 98 F3               CALL   SETTRK   ;select this track.
E817   D1                     POP   D   ;reset current track pointer.
E818   2A AF F1               LHLD   SCRATCH2   
E81B   73                     MOV   M,E   
E81C   23                     INX   H   
E81D   72                     MOV   M,D   
E81E   D1                     POP   D   
E81F   2A B1 F1               LHLD   SCRATCH3   ;reset the first sector on this track.
E822   73                     MOV   M,E   
E823   23                     INX   H   
E824   72                     MOV   M,D   
E825   C1                     POP   B   
E826   79                     MOV   A,C   ;now subtract the desired one.
E827   93                     SUB   E   ;to make it relative (1-# sectors/track).
E828   4F                     MOV   C,A   
E829   78                     MOV   A,B   
E82A   9A                     SBB   D   
E82B   47                     MOV   B,A   
E82C   2A CA F1               LHLD   XLATE   ;translate this sector according to this table.
E82F   EB                     XCHG      
E830   CD C0 F3               CALL   SECTRAN   ;let the bios translate it.
E833   4D                     MOV   C,L   
E834   44                     MOV   B,H   
E835   C3 AC F3               JMP   SETSEC   ;and select it.
E838                             ; 
E838                             ;   Compute block number from record number (SAVNREC) and
E838                             ; extent number (SAVEXT).
E838                             ; 
E838   21 BD F1     GETBLOCK:   LXI   H,BLKSHFT   ;get logical to physical conversion.
E83B   4E                     MOV   C,M   ;note that this is base 2 log of ratio.
E83C   3A DD F1               LDA   SAVNREC   ;get record number.
E83F   B7           GETBLK1:   ORA   A   ;compute (A)=(A)/2^BLKSHFT.
E840   1F                     RAR      
E841   0D                     DCR   C   
E842   C2 3F E8               JNZ   GETBLK1   
E845   47                     MOV   B,A   ;save result in (B).
E846   3E 08                  MVI   A,8   
E848   96                     SUB   M   
E849   4F                     MOV   C,A   ;compute (C)=8-BLKSHFT.
E84A   3A DC F1               LDA   SAVEXT   
E84D   0D           GETBLK2:   DCR   C   ;compute (A)=SAVEXT*2^(8-BLKSHFT).
E84E   CA 56 E8               JZ   GETBLK3   
E851   B7                     ORA   A   
E852   17                     RAL      
E853   C3 4D E8               JMP   GETBLK2   
E856   80           GETBLK3:   ADD   B   
E857   C9                     RET      
E858                             ; 
E858                             ;   Routine to extract the (BC) block byte from the fcb pointed
E858                             ; to by (PARAMS). If this is a big-disk, then these are 16 bit
E858                             ; block numbers, else they are 8 bit numbers.
E858                             ; Number is returned in (HL).
E858                             ; 
E858   2A 3D E7     EXTBLK:   LHLD   PARAMS   ;get fcb address.
E85B   11 10 00               LXI   D,16   ;block numbers start 16 bytes into fcb.
E85E   19                     DAD   D   
E85F   09                     DAD   B   
E860   3A D7 F1               LDA   BIGDISK   ;are we using a big-disk?
E863   B7                     ORA   A   
E864   CA 6B E8               JZ   EXTBLK1   
E867   6E                     MOV   L,M   ;no, extract an 8 bit number from the fcb.
E868   26 00                  MVI   H,0   
E86A   C9                     RET      
E86B   09           EXTBLK1:   DAD   B   ;yes, extract a 16 bit number.
E86C   5E                     MOV   E,M   
E86D   23                     INX   H   
E86E   56                     MOV   D,M   
E86F   EB                     XCHG      ;return in (HL).
E870   C9                     RET      
E871                             ; 
E871                             ;   Compute block number.
E871                             ; 
E871   CD 38 E8     COMBLK:   CALL   GETBLOCK   
E874   4F                     MOV   C,A   
E875   06 00                  MVI   B,0   
E877   CD 58 E8               CALL   EXTBLK   
E87A   22 DF F1               SHLD   BLKNMBR   
E87D   C9                     RET      
E87E                             ; 
E87E                             ;   Check for a zero block number (unused).
E87E                             ; 
E87E   2A DF F1     CHKBLK:   LHLD   BLKNMBR   
E881   7D                     MOV   A,L   ;is it zero?
E882   B4                     ORA   H   
E883   C9                     RET      
E884                             ; 
E884                             ;   Adjust physical block (BLKNMBR) and convert to logical
E884                             ; sector (LOGSECT). This is the starting sector of this block.
E884                             ; The actual sector of interest is then added to this and the
E884                             ; resulting sector number is stored back in (BLKNMBR). This
E884                             ; will still have to be adjusted for the track number.
E884                             ; 
E884   3A BD F1     LOGICAL:   LDA   BLKSHFT   ;get log2(physical/logical sectors).
E887   2A DF F1               LHLD   BLKNMBR   ;get physical sector desired.
E88A   29           LOGICL1:   DAD   H   ;compute logical sector number.
E88B   3D                     DCR   A   ;note logical sectors are 128 bytes long.
E88C   C2 8A E8               JNZ   LOGICL1   
E88F   22 E1 F1               SHLD   LOGSECT   ;save logical sector.
E892   3A BE F1               LDA   BLKMASK   ;get block mask.
E895   4F                     MOV   C,A   
E896   3A DD F1               LDA   SAVNREC   ;get next sector to access.
E899   A1                     ANA   C   ;extract the relative position within physical block.
E89A   B5                     ORA   L   ;and add it too logical sector.
E89B   6F                     MOV   L,A   
E89C   22 DF F1               SHLD   BLKNMBR   ;and store.
E89F   C9                     RET      
E8A0                             ; 
E8A0                             ;   Set (HL) to point to extent byte in fcb.
E8A0                             ; 
E8A0   2A 3D E7     SETEXT:   LHLD   PARAMS   
E8A3   11 0C 00               LXI   D,12   ;it is the twelth byte.
E8A6   19                     DAD   D   
E8A7   C9                     RET      
E8A8                             ; 
E8A8                             ;   Set (HL) to point to record count byte in fcb and (DE) to
E8A8                             ; next record number byte.
E8A8                             ; 
E8A8   2A 3D E7     SETHLDE:   LHLD   PARAMS   
E8AB   11 0F 00               LXI   D,15   ;record count byte (#15).
E8AE   19                     DAD   D   
E8AF   EB                     XCHG      
E8B0   21 11 00               LXI   H,17   ;next record number (#32).
E8B3   19                     DAD   D   
E8B4   C9                     RET      
E8B5                             ; 
E8B5                             ;   Save current file data from fcb.
E8B5                             ; 
E8B5   CD A8 E8     STRDATA:   CALL   SETHLDE   
E8B8   7E                     MOV   A,M   ;get and store record count byte.
E8B9   32 DD F1               STA   SAVNREC   
E8BC   EB                     XCHG      
E8BD   7E                     MOV   A,M   ;get and store next record number byte.
E8BE   32 DB F1               STA   SAVNXT   
E8C1   CD A0 E8               CALL   SETEXT   ;point to extent byte.
E8C4   3A BF F1               LDA   EXTMASK   ;get extent mask.
E8C7   A6                     ANA   M   
E8C8   32 DC F1               STA   SAVEXT   ;and save extent here.
E8CB   C9                     RET      
E8CC                             ; 
E8CC                             ;   Set the next record to access. If (MODE) is set to 2, then
E8CC                             ; the last record byte (SAVNREC) has the correct number to access.
E8CC                             ; For sequential access, (MODE) will be equal to 1.
E8CC                             ; 
E8CC   CD A8 E8     SETNREC:   CALL   SETHLDE   
E8CF   3A CF F1               LDA   MODE   ;get sequential flag (=1).
E8D2   FE 02                  CPI   2   ;a 2 indicates that no adder is needed.
E8D4   C2 D8 E8               JNZ   STNREC1   
E8D7   AF                     XRA   A   ;clear adder (random access?).
E8D8   4F           STNREC1:   MOV   C,A   
E8D9   3A DD F1               LDA   SAVNREC   ;get last record number.
E8DC   81                     ADD   C   ;increment record count.
E8DD   77                     MOV   M,A   ;and set fcb's next record byte.
E8DE   EB                     XCHG      
E8DF   3A DB F1               LDA   SAVNXT   ;get next record byte from storage.
E8E2   77                     MOV   M,A   ;and put this into fcb as number of records used.
E8E3   C9                     RET      
E8E4                             ; 
E8E4                             ;   Shift (HL) right (C) bits.
E8E4                             ; 
E8E4   0C           SHIFTR:   INR   C   
E8E5   0D           SHIFTR1:   DCR   C   
E8E6   C8                     RZ      
E8E7   7C                     MOV   A,H   
E8E8   B7                     ORA   A   
E8E9   1F                     RAR      
E8EA   67                     MOV   H,A   
E8EB   7D                     MOV   A,L   
E8EC   1F                     RAR      
E8ED   6F                     MOV   L,A   
E8EE   C3 E5 E8               JMP   SHIFTR1   
E8F1                             ; 
E8F1                             ;   Compute the check-sum for the directory buffer. Return
E8F1                             ; integer sum in (A).
E8F1                             ; 
E8F1   0E 80        CHECKSUM:   MVI   C,128   ;length of buffer.
E8F3   2A B3 F1               LHLD   DIRBUF   ;get its location.
E8F6   AF                     XRA   A   ;clear summation byte.
E8F7   86           CHKSUM1:   ADD   M   ;and compute sum ignoring carries.
E8F8   23                     INX   H   
E8F9   0D                     DCR   C   
E8FA   C2 F7 E8               JNZ   CHKSUM1   
E8FD   C9                     RET      
E8FE                             ; 
E8FE                             ;   Shift (HL) left (C) bits.
E8FE                             ; 
E8FE   0C           SHIFTL:   INR   C   
E8FF   0D           SHIFTL1:   DCR   C   
E900   C8                     RZ      
E901   29                     DAD   H   ;shift left 1 bit.
E902   C3 FF E8               JMP   SHIFTL1   
E905                             ; 
E905                             ;   Routine to set a bit in a 16 bit value contained in (BC).
E905                             ; The bit set depends on the current drive selection.
E905                             ; 
E905   C5           SETBIT:   PUSH   B   ;save 16 bit word.
E906   3A 3C E7               LDA   ACTIVE   ;get active drive.
E909   4F                     MOV   C,A   
E90A   21 01 00               LXI   H,1   
E90D   CD FE E8               CALL   SHIFTL   ;shift bit 0 into place.
E910   C1                     POP   B   ;now "or" this with the original word.
E911   79                     MOV   A,C   
E912   B5                     ORA   L   
E913   6F                     MOV   L,A   ;low byte done, do high byte.
E914   78                     MOV   A,B   
E915   B4                     ORA   H   
E916   67                     MOV   H,A   
E917   C9                     RET      
E918                             ; 
E918                             ;   Extract the write protect status bit for the current drive.
E918                             ; The result is returned in (A), bit 0.
E918                             ; 
E918   2A A7 F1     GETWPRT:   LHLD   WRTPRT   ;get status bytes.
E91B   3A 3C E7               LDA   ACTIVE   ;which drive is current?
E91E   4F                     MOV   C,A   
E91F   CD E4 E8               CALL   SHIFTR   ;shift status such that bit 0 is the
E922   7D                     MOV   A,L   ;one of interest for this drive.
E923   E6 01                  ANI   01H   ;and isolate it.
E925   C9                     RET      
E926                             ; 
E926                             ;   Function to write protect the current disk.
E926                             ; 
E926   21 A7 F1     WRTPRTD:   LXI   H,WRTPRT   ;point to status word.
E929   4E                     MOV   C,M   ;set (BC) equal to the status.
E92A   23                     INX   H   
E92B   46                     MOV   B,M   
E92C   CD 05 E9               CALL   SETBIT   ;and set this bit according to current drive.
E92F   22 A7 F1               SHLD   WRTPRT   ;then save.
E932   2A C2 F1               LHLD   DIRSIZE   ;now save directory size limit.
E935   23                     INX   H   ;remember the last one.
E936   EB                     XCHG      
E937   2A AD F1               LHLD   SCRATCH1   ;and store it here.
E93A   73                     MOV   M,E   ;put low byte.
E93B   23                     INX   H   
E93C   72                     MOV   M,D   ;then high byte.
E93D   C9                     RET      
E93E                             ; 
E93E                             ;   Check for a read only file.
E93E                             ; 
E93E   CD 58 E9     CHKROFL:   CALL   FCB2HL   ;set (HL) to file entry in directory buffer.
E941   11 09 00     CKROF1:   LXI   D,9   ;look at bit 7 of the ninth byte.
E944   19                     DAD   D   
E945   7E                     MOV   A,M   
E946   17                     RAL      
E947   D0                     RNC      ;return if ok.
E948   21 09 E4               LXI   H,ROFILE   ;else, print error message and terminate.
E94B   C3 44 E7               JMP   JUMPHL   
E94E                             ; 
E94E                             ;   Check the write protect status of the active disk.
E94E                             ; 
E94E   CD 18 E9     CHKWPRT:   CALL   GETWPRT   
E951   C8                     RZ      ;return if ok.
E952   21 07 E4               LXI   H,RODISK   ;else print message and terminate.
E955   C3 44 E7               JMP   JUMPHL   
E958                             ; 
E958                             ;   Routine to set (HL) pointing to the proper entry in the
E958                             ; directory buffer.
E958                             ; 
E958   2A B3 F1     FCB2HL:   LHLD   DIRBUF   ;get address of buffer.
E95B   3A E3 F1               LDA   FCBPOS   ;relative position of file.
E95E                             ; 
E95E                             ;   Routine to add (A) to (HL).
E95E                             ; 
E95E   85           ADDA2HL:   ADD   L   
E95F   6F                     MOV   L,A   
E960   D0                     RNC      
E961   24                     INR   H   ;take care of any carry.
E962   C9                     RET      
E963                             ; 
E963                             ;   Routine to get the "s2" byte from the fcb supplied in
E963                             ; the initial parameter specification.
E963                             ; 
E963   2A 3D E7     GETS2:    LHLD   PARAMS   ;get address of fcb.
E966   11 0E 00               LXI   D,14   ;relative position of "s2".
E969   19                     DAD   D   
E96A   7E                     MOV   A,M   ;extract this byte.
E96B   C9                     RET      
E96C                             ; 
E96C                             ;   Clear the "s2" byte in the fcb.
E96C                             ; 
E96C   CD 63 E9     CLEARS2:   CALL   GETS2   ;this sets (HL) pointing to it.
E96F   36 00                  MVI   M,0   ;now clear it.
E971   C9                     RET      
E972                             ; 
E972                             ;   Set bit 7 in the "s2" byte of the fcb.
E972                             ; 
E972   CD 63 E9     SETS2B7:   CALL   GETS2   ;get the byte.
E975   F6 80                  ORI   80H   ;and set bit 7.
E977   77                     MOV   M,A   ;then store.
E978   C9                     RET      
E979                             ; 
E979                             ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
E979                             ; the difference. This checks to see if there are more file
E979                             ; names in the directory. We are at (FILEPOS) and there are
E979                             ; (SCRATCH1) of them to check.
E979                             ; 
E979   2A E4 F1     MOREFLS:   LHLD   FILEPOS   ;we are here.
E97C   EB                     XCHG      
E97D   2A AD F1               LHLD   SCRATCH1   ;and don't go past here.
E980   7B                     MOV   A,E   ;compute difference but don't keep.
E981   96                     SUB   M   
E982   23                     INX   H   
E983   7A                     MOV   A,D   
E984   9E                     SBB   M   ;set carry if no more names.
E985   C9                     RET      
E986                             ; 
E986                             ;   Call this routine to prevent (SCRATCH1) from being greater
E986                             ; than (FILEPOS).
E986                             ; 
E986   CD 79 E9     CHKNMBR:   CALL   MOREFLS   ;SCRATCH1 too big?
E989   D8                     RC      
E98A   13                     INX   D   ;yes, reset it to (FILEPOS).
E98B   72                     MOV   M,D   
E98C   2B                     DCX   H   
E98D   73                     MOV   M,E   
E98E   C9                     RET      
E98F                             ; 
E98F                             ;   Compute (HL)=(DE)-(HL)
E98F                             ; 
E98F   7B           SUBHL:    MOV   A,E   ;compute difference.
E990   95                     SUB   L   
E991   6F                     MOV   L,A   ;store low byte.
E992   7A                     MOV   A,D   
E993   9C                     SBB   H   
E994   67                     MOV   H,A   ;and then high byte.
E995   C9                     RET      
E996                             ; 
E996                             ;   Set the directory checksum byte.
E996                             ; 
E996   0E FF        SETDIR:   MVI   C,0FFH   
E998                             ; 
E998                             ;   Routine to set or compare the directory checksum byte. If
E998                             ; (C)=0ffh, then this will set the checksum byte. Else the byte
E998                             ; will be checked. If the check fails (the disk has been changed),
E998                             ; then this disk will be write protected.
E998                             ; 
E998   2A E6 F1     CHECKDIR:   LHLD   CKSUMTBL   
E99B   EB                     XCHG      
E99C   2A C6 F1               LHLD   ALLOC1   
E99F   CD 8F E9               CALL   SUBHL   
E9A2   D0                     RNC      ;ok if (CKSUMTBL) > (ALLOC1), so return.
E9A3   C5                     PUSH   B   
E9A4   CD F1 E8               CALL   CHECKSUM   ;else compute checksum.
E9A7   2A B7 F1               LHLD   CHKVECT   ;get address of checksum table.
E9AA   EB                     XCHG      
E9AB   2A E6 F1               LHLD   CKSUMTBL   
E9AE   19                     DAD   D   ;set (HL) to point to byte for this drive.
E9AF   C1                     POP   B   
E9B0   0C                     INR   C   ;set or check ?
E9B1   CA BE E9               JZ   CHKDIR1   
E9B4   BE                     CMP   M   ;check them.
E9B5   C8                     RZ      ;return if they are the same.
E9B6   CD 79 E9               CALL   MOREFLS   ;not the same, do we care?
E9B9   D0                     RNC      
E9BA   CD 26 E9               CALL   WRTPRTD   ;yes, mark this as write protected.
E9BD   C9                     RET      
E9BE   77           CHKDIR1:   MOV   M,A   ;just set the byte.
E9BF   C9                     RET      
E9C0                             ; 
E9C0                             ;   Do a write to the directory of the current disk.
E9C0                             ; 
E9C0   CD 96 E9     DIRWRITE:   CALL   SETDIR   ;set checksum byte.
E9C3   CD DA E9               CALL   DIRDMA   ;set directory dma address.
E9C6   0E 01                  MVI   C,1   ;tell the bios to actually write.
E9C8   CD B2 E7               CALL   DOWRITE   ;then do the write.
E9CB   C3 D4 E9               JMP   DEFDMA   
E9CE                             ; 
E9CE                             ;   Read from the directory.
E9CE                             ; 
E9CE   CD DA E9     DIRREAD:   CALL   DIRDMA   ;set the directory dma address.
E9D1   CD AC E7               CALL   DOREAD   ;and read it.
E9D4                             ; 
E9D4                             ;   Routine to set the dma address to the users choice.
E9D4                             ; 
E9D4   21 AB F1     DEFDMA:   LXI   H,USERDMA   ;reset the default dma address and return.
E9D7   C3 DD E9               JMP   DIRDMA1   
E9DA                             ; 
E9DA                             ;   Routine to set the dma address for directory work.
E9DA                             ; 
E9DA   21 B3 F1     DIRDMA:   LXI   H,DIRBUF   
E9DD                             ; 
E9DD                             ;   Set the dma address. On entry, (HL) points to
E9DD                             ; word containing the desired dma address.
E9DD                             ; 
E9DD   4E           DIRDMA1:   MOV   C,M   
E9DE   23                     INX   H   
E9DF   46                     MOV   B,M   ;setup (BC) and go to the bios to set it.
E9E0   C3 C3 F3               JMP   SETDMA   
E9E3                             ; 
E9E3                             ;   Move the directory buffer into user's dma space.
E9E3                             ; 
E9E3   2A B3 F1     MOVEDIR:   LHLD   DIRBUF   ;buffer is located here, and
E9E6   EB                     XCHG      
E9E7   2A AB F1               LHLD   USERDMA   ; put it here.
E9EA   0E 80                  MVI   C,128   ;this is its length.
E9EC   C3 49 E7               JMP   DE2HL   ;move it now and return.
E9EF                             ; 
E9EF                             ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
E9EF                             ; 
E9EF   21 E4 F1     CKFILPOS:   LXI   H,FILEPOS   
E9F2   7E                     MOV   A,M   
E9F3   23                     INX   H   
E9F4   BE                     CMP   M   ;are both bytes the same?
E9F5   C0                     RNZ      
E9F6   3C                     INR   A   ;yes, but are they each 0ffh?
E9F7   C9                     RET      
E9F8                             ; 
E9F8                             ;   Set location (FILEPOS) to 0ffffh.
E9F8                             ; 
E9F8   21 FF FF     STFILPOS:   LXI   H,0FFFFH   
E9FB   22 E4 F1               SHLD   FILEPOS   
E9FE   C9                     RET      
E9FF                             ; 
E9FF                             ;   Move on to the next file position within the current
E9FF                             ; directory buffer. If no more exist, set pointer to 0ffffh
E9FF                             ; and the calling routine will check for this. Enter with (C)
E9FF                             ; equal to 0ffh to cause the checksum byte to be set, else we
E9FF                             ; will check this disk and set write protect if checksums are
E9FF                             ; not the same (applies only if another directory sector must
E9FF                             ; be read).
E9FF                             ; 
E9FF   2A C2 F1     NXENTRY:   LHLD   DIRSIZE   ;get directory entry size limit.
EA02   EB                     XCHG      
EA03   2A E4 F1               LHLD   FILEPOS   ;get current count.
EA06   23                     INX   H   ;go on to the next one.
EA07   22 E4 F1               SHLD   FILEPOS   
EA0A   CD 8F E9               CALL   SUBHL   ;(HL)=(DIRSIZE)-(FILEPOS)
EA0D   D2 13 EA               JNC   NXENT1   ;is there more room left?
EA10   C3 F8 E9               JMP   STFILPOS   ;no. Set this flag and return.
EA13   3A E4 F1     NXENT1:   LDA   FILEPOS   ;get file position within directory.
EA16   E6 03                  ANI   03H   ;only look within this sector (only 4 entries fit).
EA18   06 05                  MVI   B,5   ;convert to relative position (32 bytes each).
EA1A   87           NXENT2:   ADD   A   ;note that this is not efficient code.
EA1B   05                     DCR   B   ;5 "ADD A"s would be better.
EA1C   C2 1A EA               JNZ   NXENT2   
EA1F   32 E3 F1               STA   FCBPOS   ;save it as position of fcb.
EA22   B7                     ORA   A   
EA23   C0                     RNZ      ;return if we are within buffer.
EA24   C5                     PUSH   B   
EA25   CD BD E7               CALL   TRKSEC   ;we need the next directory sector.
EA28   CD CE E9               CALL   DIRREAD   
EA2B   C1                     POP   B   
EA2C   C3 98 E9               JMP   CHECKDIR   
EA2F                             ; 
EA2F                             ;   Routine to to get a bit from the disk space allocation
EA2F                             ; map. It is returned in (A), bit position 0. On entry to here,
EA2F                             ; set (BC) to the block number on the disk to check.
EA2F                             ; On return, (D) will contain the original bit position for
EA2F                             ; this block number and (HL) will point to the address for it.
EA2F                             ; 
EA2F   79           CKBITMAP:   MOV   A,C   ;determine bit number of interest.
EA30   E6 07                  ANI   07H   ;compute (D)=(E)=(C and 7)+1.
EA32   3C                     INR   A   
EA33   5F                     MOV   E,A   ;save particular bit number.
EA34   57                     MOV   D,A   
EA35                             ; 
EA35                             ;   compute (BC)=(BC)/8.
EA35                             ; 
EA35   79                     MOV   A,C   
EA36   0F                     RRC      ;now shift right 3 bits.
EA37   0F                     RRC      
EA38   0F                     RRC      
EA39   E6 1F                  ANI   1FH   ;and clear bits 7,6,5.
EA3B   4F                     MOV   C,A   
EA3C   78                     MOV   A,B   
EA3D   87                     ADD   A   ;now shift (B) into bits 7,6,5.
EA3E   87                     ADD   A   
EA3F   87                     ADD   A   
EA40   87                     ADD   A   
EA41   87                     ADD   A   
EA42   B1                     ORA   C   ;and add in (C).
EA43   4F                     MOV   C,A   ;ok, (C) ha been completed.
EA44   78                     MOV   A,B   ;is there a better way of doing this?
EA45   0F                     RRC      
EA46   0F                     RRC      
EA47   0F                     RRC      
EA48   E6 1F                  ANI   1FH   
EA4A   47                     MOV   B,A   ;and now (B) is completed.
EA4B                             ; 
EA4B                             ;   use this as an offset into the disk space allocation
EA4B                             ; table.
EA4B                             ; 
EA4B   2A B9 F1               LHLD   ALOCVECT   
EA4E   09                     DAD   B   
EA4F   7E                     MOV   A,M   ;now get correct byte.
EA50   07           CKBMAP1:   RLC      ;get correct bit into position 0.
EA51   1D                     DCR   E   
EA52   C2 50 EA               JNZ   CKBMAP1   
EA55   C9                     RET      
EA56                             ; 
EA56                             ;   Set or clear the bit map such that block number (BC) will be marked
EA56                             ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
EA56                             ; 1 then it will be set (don't use anyother values).
EA56                             ; 
EA56   D5           STBITMAP:   PUSH   D   
EA57   CD 2F EA               CALL   CKBITMAP   ;get the byte of interest.
EA5A   E6 FE                  ANI   0FEH   ;clear the affected bit.
EA5C   C1                     POP   B   
EA5D   B1                     ORA   C   ;and now set it acording to (C).
EA5E                             ; 
EA5E                             ;  entry to restore the original bit position and then store
EA5E                             ; in table. (A) contains the value, (D) contains the bit
EA5E                             ; position (1-8), and (HL) points to the address within the
EA5E                             ; space allocation table for this byte.
EA5E                             ; 
EA5E   0F           STBMAP1:   RRC      ;restore original bit position.
EA5F   15                     DCR   D   
EA60   C2 5E EA               JNZ   STBMAP1   
EA63   77                     MOV   M,A   ;and stor byte in table.
EA64   C9                     RET      
EA65                             ; 
EA65                             ;   Set/clear space used bits in allocation map for this file.
EA65                             ; On entry, (C)=1 to set the map and (C)=0 to clear it.
EA65                             ; 
EA65   CD 58 E9     SETFILE:   CALL   FCB2HL   ;get address of fcb
EA68   11 10 00               LXI   D,16   
EA6B   19                     DAD   D   ;get to block number bytes.
EA6C   C5                     PUSH   B   
EA6D   0E 11                  MVI   C,17   ;check all 17 bytes (max) of table.
EA6F   D1           SETFL1:   POP   D   
EA70   0D                     DCR   C   ;done all bytes yet?
EA71   C8                     RZ      
EA72   D5                     PUSH   D   
EA73   3A D7 F1               LDA   BIGDISK   ;check disk size for 16 bit block numbers.
EA76   B7                     ORA   A   
EA77   CA 82 EA               JZ   SETFL2   
EA7A   C5                     PUSH   B   ;only 8 bit numbers. set (BC) to this one.
EA7B   E5                     PUSH   H   
EA7C   4E                     MOV   C,M   ;get low byte from table, always
EA7D   06 00                  MVI   B,0   ;set high byte to zero.
EA7F   C3 88 EA               JMP   SETFL3   
EA82   0D           SETFL2:   DCR   C   ;for 16 bit block numbers, adjust counter.
EA83   C5                     PUSH   B   
EA84   4E                     MOV   C,M   ;now get both the low and high bytes.
EA85   23                     INX   H   
EA86   46                     MOV   B,M   
EA87   E5                     PUSH   H   
EA88   79           SETFL3:   MOV   A,C   ;block used?
EA89   B0                     ORA   B   
EA8A   CA 97 EA               JZ   SETFL4   
EA8D   2A C0 F1               LHLD   DSKSIZE   ;is this block number within the
EA90   7D                     MOV   A,L   ;space on the disk?
EA91   91                     SUB   C   
EA92   7C                     MOV   A,H   
EA93   98                     SBB   B   
EA94   D4 56 EA               CNC   STBITMAP   ;yes, set the proper bit.
EA97   E1           SETFL4:   POP   H   ;point to next block number in fcb.
EA98   23                     INX   H   
EA99   C1                     POP   B   
EA9A   C3 6F EA               JMP   SETFL1   
EA9D                             ; 
EA9D                             ;   Construct the space used allocation bit map for the active
EA9D                             ; drive. If a file name starts with "$" and it is under the
EA9D                             ; current user number, then (STATUS) is set to minus 1. Otherwise
EA9D                             ; it is not set at all.
EA9D                             ; 
EA9D   2A C0 F1     BITMAP:   LHLD   DSKSIZE   ;compute size of allocation table.
EAA0   0E 03                  MVI   C,3   
EAA2   CD E4 E8               CALL   SHIFTR   ;(HL)=(HL)/8.
EAA5   23                     INX   H   ;at lease 1 byte.
EAA6   44                     MOV   B,H   
EAA7   4D                     MOV   C,L   ;set (BC) to the allocation table length.
EAA8                             ; 
EAA8                             ;   Initialize the bitmap for this drive. Right now, the first
EAA8                             ; two bytes are specified by the disk parameter block. However
EAA8                             ; a patch could be entered here if it were necessary to setup
EAA8                             ; this table in a special mannor. For example, the bios could
EAA8                             ; determine locations of "bad blocks" and set them as already
EAA8                             ; "used" in the map.
EAA8                             ; 
EAA8   2A B9 F1               LHLD   ALOCVECT   ;now zero out the table now.
EAAB   36 00        BITMAP1:   MVI   M,0   
EAAD   23                     INX   H   
EAAE   0B                     DCX   B   
EAAF   78                     MOV   A,B   
EAB0   B1                     ORA   C   
EAB1   C2 AB EA               JNZ   BITMAP1   
EAB4   2A C4 F1               LHLD   ALLOC0   ;get initial space used by directory.
EAB7   EB                     XCHG      
EAB8   2A B9 F1               LHLD   ALOCVECT   ;and put this into map.
EABB   73                     MOV   M,E   
EABC   23                     INX   H   
EABD   72                     MOV   M,D   
EABE                             ; 
EABE                             ;   End of initialization portion.
EABE                             ; 
EABE   CD 9B E7               CALL   HOMEDRV   ;now home the drive.
EAC1   2A AD F1               LHLD   SCRATCH1   
EAC4   36 03                  MVI   M,3   ;force next directory request to read
EAC6   23                     INX   H   ;in a sector.
EAC7   36 00                  MVI   M,0   
EAC9   CD F8 E9               CALL   STFILPOS   ;clear initial file position also.
EACC   0E FF        BITMAP2:   MVI   C,0FFH   ;read next file name in directory
EACE   CD FF E9               CALL   NXENTRY   ;and set checksum byte.
EAD1   CD EF E9               CALL   CKFILPOS   ;is there another file?
EAD4   C8                     RZ      
EAD5   CD 58 E9               CALL   FCB2HL   ;yes, get its address.
EAD8   3E E5                  MVI   A,0E5H   
EADA   BE                     CMP   M   ;empty file entry?
EADB   CA CC EA               JZ   BITMAP2   
EADE   3A 3B E7               LDA   USERNO   ;no, correct user number?
EAE1   BE                     CMP   M   
EAE2   C2 F0 EA               JNZ   BITMAP3   
EAE5   23                     INX   H   
EAE6   7E                     MOV   A,M   ;yes, does name start with a "$"?
EAE7   D6 24                  SUI   "$"   
EAE9   C2 F0 EA               JNZ   BITMAP3   
EAEC   3D                     DCR   A   ;yes, set atatus to minus one.
EAED   32 3F E7               STA   STATUS   
EAF0   0E 01        BITMAP3:   MVI   C,1   ;now set this file's space as used in bit map.
EAF2   CD 65 EA               CALL   SETFILE   
EAF5   CD 86 E9               CALL   CHKNMBR   ;keep (SCRATCH1) in bounds.
EAF8   C3 CC EA               JMP   BITMAP2   
EAFB                             ; 
EAFB                             ;   Set the status (STATUS) and return.
EAFB                             ; 
EAFB   3A CE F1     STSTATUS:   LDA   FNDSTAT   
EAFE   C3 FB E6               JMP   SETSTAT   
EB01                             ; 
EB01                             ;   Check extents in (A) and (C). Set the zero flag if they
EB01                             ; are the same. The number of 16k chunks of disk space that
EB01                             ; the directory extent covers is expressad is (EXTMASK+1).
EB01                             ; No registers are modified.
EB01                             ; 
EB01   C5           SAMEXT:   PUSH   B   
EB02   F5                     PUSH   PSW   
EB03   3A BF F1               LDA   EXTMASK   ;get extent mask and use it to
EB06   2F                     CMA      ;to compare both extent numbers.
EB07   47                     MOV   B,A   ;save resulting mask here.
EB08   79                     MOV   A,C   ;mask first extent and save in (C).
EB09   A0                     ANA   B   
EB0A   4F                     MOV   C,A   
EB0B   F1                     POP   PSW   ;now mask second extent and compare
EB0C   A0                     ANA   B   ;with the first one.
EB0D   91                     SUB   C   
EB0E   E6 1F                  ANI   1FH   ;(* only check buts 0-4 *)
EB10   C1                     POP   B   ;the zero flag is set if they are the same.
EB11   C9                     RET      ;restore (BC) and return.
EB12                             ; 
EB12                             ;   Search for the first occurence of a file name. On entry,
EB12                             ; register (C) should contain the number of bytes of the fcb
EB12                             ; that must match.
EB12                             ; 
EB12   3E FF        FINDFST:   MVI   A,0FFH   
EB14   32 CE F1               STA   FNDSTAT   
EB17   21 D2 F1               LXI   H,COUNTER   ;save character count.
EB1A   71                     MOV   M,C   
EB1B   2A 3D E7               LHLD   PARAMS   ;get filename to match.
EB1E   22 D3 F1               SHLD   SAVEFCB   ;and save.
EB21   CD F8 E9               CALL   STFILPOS   ;clear initial file position (set to 0ffffh).
EB24   CD 9B E7               CALL   HOMEDRV   ;home the drive.
EB27                             ; 
EB27                             ;   Entry to locate the next occurence of a filename within the
EB27                             ; directory. The disk is not expected to have been changed. If
EB27                             ; it was, then it will be write protected.
EB27                             ; 
EB27   0E 00        FINDNXT:   MVI   C,0   ;write protect the disk if changed.
EB29   CD FF E9               CALL   NXENTRY   ;get next filename entry in directory.
EB2C   CD EF E9               CALL   CKFILPOS   ;is file position = 0ffffh?
EB2F   CA 8E EB               JZ   FNDNXT6   ;yes, exit now then.
EB32   2A D3 F1               LHLD   SAVEFCB   ;set (DE) pointing to filename to match.
EB35   EB                     XCHG      
EB36   1A                     LDAX   D   
EB37   FE E5                  CPI   0E5H   ;empty directory entry?
EB39   CA 44 EB               JZ   FNDNXT1   ;(* are we trying to reserect erased entries? *)
EB3C   D5                     PUSH   D   
EB3D   CD 79 E9               CALL   MOREFLS   ;more files in directory?
EB40   D1                     POP   D   
EB41   D2 8E EB               JNC   FNDNXT6   ;no more. Exit now.
EB44   CD 58 E9     FNDNXT1:   CALL   FCB2HL   ;get address of this fcb in directory.
EB47   3A D2 F1               LDA   COUNTER   ;get number of bytes (characters) to check.
EB4A   4F                     MOV   C,A   
EB4B   06 00                  MVI   B,0   ;initialize byte position counter.
EB4D   79           FNDNXT2:   MOV   A,C   ;are we done with the compare?
EB4E   B7                     ORA   A   
EB4F   CA 7D EB               JZ   FNDNXT5   
EB52   1A                     LDAX   D   ;no, check next byte.
EB53   FE 3F                  CPI   "?"   ;don't care about this character?
EB55   CA 76 EB               JZ   FNDNXT4   
EB58   78                     MOV   A,B   ;get bytes position in fcb.
EB59   FE 0D                  CPI   13   ;don't care about the thirteenth byte either.
EB5B   CA 76 EB               JZ   FNDNXT4   
EB5E   FE 0C                  CPI   12   ;extent byte?
EB60   1A                     LDAX   D   
EB61   CA 6D EB               JZ   FNDNXT3   
EB64   96                     SUB   M   ;otherwise compare characters.
EB65   E6 7F                  ANI   7FH   
EB67   C2 27 EB               JNZ   FINDNXT   ;not the same, check next entry.
EB6A   C3 76 EB               JMP   FNDNXT4   ;so far so good, keep checking.
EB6D   C5           FNDNXT3:   PUSH   B   ;check the extent byte here.
EB6E   4E                     MOV   C,M   
EB6F   CD 01 EB               CALL   SAMEXT   
EB72   C1                     POP   B   
EB73   C2 27 EB               JNZ   FINDNXT   ;not the same, look some more.
EB76                             ; 
EB76                             ;   So far the names compare. Bump pointers to the next byte
EB76                             ; and continue until all (C) characters have been checked.
EB76                             ; 
EB76   13           FNDNXT4:   INX   D   ;bump pointers.
EB77   23                     INX   H   
EB78   04                     INR   B   
EB79   0D                     DCR   C   ;adjust character counter.
EB7A   C3 4D EB               JMP   FNDNXT2   
EB7D   3A E4 F1     FNDNXT5:   LDA   FILEPOS   ;return the position of this entry.
EB80   E6 03                  ANI   03H   
EB82   32 3F E7               STA   STATUS   
EB85   21 CE F1               LXI   H,FNDSTAT   
EB88   7E                     MOV   A,M   
EB89   17                     RAL      
EB8A   D0                     RNC      
EB8B   AF                     XRA   A   
EB8C   77                     MOV   M,A   
EB8D   C9                     RET      
EB8E                             ; 
EB8E                             ;   Filename was not found. Set appropriate status.
EB8E                             ; 
EB8E   CD F8 E9     FNDNXT6:   CALL   STFILPOS   ;set (FILEPOS) to 0ffffh.
EB91   3E FF                  MVI   A,0FFH   ;say not located.
EB93   C3 FB E6               JMP   SETSTAT   
EB96                             ; 
EB96                             ;   Erase files from the directory. Only the first byte of the
EB96                             ; fcb will be affected. It is set to (E5).
EB96                             ; 
EB96   CD 4E E9     ERAFILE:   CALL   CHKWPRT   ;is disk write protected?
EB99   0E 0C                  MVI   C,12   ;only compare file names.
EB9B   CD 12 EB               CALL   FINDFST   ;get first file name.
EB9E   CD EF E9     ERAFIL1:   CALL   CKFILPOS   ;any found?
EBA1   C8                     RZ      ;nope, we must be done.
EBA2   CD 3E E9               CALL   CHKROFL   ;is file read only?
EBA5   CD 58 E9               CALL   FCB2HL   ;nope, get address of fcb and
EBA8   36 E5                  MVI   M,0E5H   ;set first byte to "empty".
EBAA   0E 00                  MVI   C,0   ;clear the space from the bit map.
EBAC   CD 65 EA               CALL   SETFILE   
EBAF   CD C0 E9               CALL   DIRWRITE   ;now write the directory sector back out.
EBB2   CD 27 EB               CALL   FINDNXT   ;find the next file name.
EBB5   C3 9E EB               JMP   ERAFIL1   ;and repeat process.
EBB8                             ; 
EBB8                             ;   Look through the space allocation map (bit map) for the
EBB8                             ; next available block. Start searching at block number (BC-1).
EBB8                             ; The search procedure is to look for an empty block that is
EBB8                             ; before the starting block. If not empty, look at a later
EBB8                             ; block number. In this way, we return the closest empty block
EBB8                             ; on either side of the "target" block number. This will speed
EBB8                             ; access on random devices. For serial devices, this should be
EBB8                             ; changed to look in the forward direction first and then start
EBB8                             ; at the front and search some more.
EBB8                             ; 
EBB8                             ;   On return, (DE)= block number that is empty and (HL) =0
EBB8                             ; if no empry block was found.
EBB8                             ; 
EBB8   50           FNDSPACE:   MOV   D,B   ;set (DE) as the block that is checked.
EBB9   59                     MOV   E,C   
EBBA                             ; 
EBBA                             ;   Look before target block. Registers (BC) are used as the lower
EBBA                             ; pointer and (DE) as the upper pointer.
EBBA                             ; 
EBBA   79           FNDSPA1:   MOV   A,C   ;is block 0 specified?
EBBB   B0                     ORA   B   
EBBC   CA CB EB               JZ   FNDSPA2   
EBBF   0B                     DCX   B   ;nope, check previous block.
EBC0   D5                     PUSH   D   
EBC1   C5                     PUSH   B   
EBC2   CD 2F EA               CALL   CKBITMAP   
EBC5   1F                     RAR      ;is this block empty?
EBC6   D2 E6 EB               JNC   FNDSPA3   ;yes. use this.
EBC9                             ; 
EBC9                             ;   Note that the above logic gets the first block that it finds
EBC9                             ; that is empty. Thus a file could be written "backward" making
EBC9                             ; it very slow to access. This could be changed to look for the
EBC9                             ; first empty block and then continue until the start of this
EBC9                             ; empty space is located and then used that starting block.
EBC9                             ; This should help speed up access to some files especially on
EBC9                             ; a well used disk with lots of fairly small "holes".
EBC9                             ; 
EBC9   C1                     POP   B   ;nope, check some more.
EBCA   D1                     POP   D   
EBCB                             ; 
EBCB                             ;   Now look after target block.
EBCB                             ; 
EBCB   2A C0 F1     FNDSPA2:   LHLD   DSKSIZE   ;is block (DE) within disk limits?
EBCE   7B                     MOV   A,E   
EBCF   95                     SUB   L   
EBD0   7A                     MOV   A,D   
EBD1   9C                     SBB   H   
EBD2   D2 EE EB               JNC   FNDSPA4   
EBD5   13                     INX   D   ;yes, move on to next one.
EBD6   C5                     PUSH   B   
EBD7   D5                     PUSH   D   
EBD8   42                     MOV   B,D   
EBD9   4B                     MOV   C,E   
EBDA   CD 2F EA               CALL   CKBITMAP   ;check it.
EBDD   1F                     RAR      ;empty?
EBDE   D2 E6 EB               JNC   FNDSPA3   
EBE1   D1                     POP   D   ;nope, continue searching.
EBE2   C1                     POP   B   
EBE3   C3 BA EB               JMP   FNDSPA1   
EBE6                             ; 
EBE6                             ;   Empty block found. Set it as used and return with (HL)
EBE6                             ; pointing to it (true?).
EBE6                             ; 
EBE6   17           FNDSPA3:   RAL      ;reset byte.
EBE7   3C                     INR   A   ;and set bit 0.
EBE8   CD 5E EA               CALL   STBMAP1   ;update bit map.
EBEB   E1                     POP   H   ;set return registers.
EBEC   D1                     POP   D   
EBED   C9                     RET      
EBEE                             ; 
EBEE                             ;   Free block was not found. If (BC) is not zero, then we have
EBEE                             ; not checked all of the disk space.
EBEE                             ; 
EBEE   79           FNDSPA4:   MOV   A,C   
EBEF   B0                     ORA   B   
EBF0   C2 BA EB               JNZ   FNDSPA1   
EBF3   21 00 00               LXI   H,0   ;set "not found" status.
EBF6   C9                     RET      
EBF7                             ; 
EBF7                             ;   Move a complete fcb entry into the directory and write it.
EBF7                             ; 
EBF7   0E 00        FCBSET:   MVI   C,0   
EBF9   1E 20                  MVI   E,32   ;length of each entry.
EBFB                             ; 
EBFB                             ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
EBFB                             ; fcb in directory starting at relative byte (C). This updated
EBFB                             ; directory buffer is then written to the disk.
EBFB                             ; 
EBFB   D5           UPDATE:   PUSH   D   
EBFC   06 00                  MVI   B,0   ;set (BC) to relative byte position.
EBFE   2A 3D E7               LHLD   PARAMS   ;get address of fcb.
EC01   09                     DAD   B   ;compute starting byte.
EC02   EB                     XCHG      
EC03   CD 58 E9               CALL   FCB2HL   ;get address of fcb to update in directory.
EC06   C1                     POP   B   ;set (C) to number of bytes to change.
EC07   CD 49 E7               CALL   DE2HL   
EC0A   CD BD E7     UPDATE1:   CALL   TRKSEC   ;determine the track and sector affected.
EC0D   C3 C0 E9               JMP   DIRWRITE   ;then write this sector out.
EC10                             ; 
EC10                             ;   Routine to change the name of all files on the disk with a
EC10                             ; specified name. The fcb contains the current name as the
EC10                             ; first 12 characters and the new name 16 bytes into the fcb.
EC10                             ; 
EC10   CD 4E E9     CHGNAMES:   CALL   CHKWPRT   ;check for a write protected disk.
EC13   0E 0C                  MVI   C,12   ;match first 12 bytes of fcb only.
EC15   CD 12 EB               CALL   FINDFST   ;get first name.
EC18   2A 3D E7               LHLD   PARAMS   ;get address of fcb.
EC1B   7E                     MOV   A,M   ;get user number.
EC1C   11 10 00               LXI   D,16   ;move over to desired name.
EC1F   19                     DAD   D   
EC20   77                     MOV   M,A   ;keep same user number.
EC21   CD EF E9     CHGNAM1:   CALL   CKFILPOS   ;any matching file found?
EC24   C8                     RZ      ;no, we must be done.
EC25   CD 3E E9               CALL   CHKROFL   ;check for read only file.
EC28   0E 10                  MVI   C,16   ;start 16 bytes into fcb.
EC2A   1E 0C                  MVI   E,12   ;and update the first 12 bytes of directory.
EC2C   CD FB EB               CALL   UPDATE   
EC2F   CD 27 EB               CALL   FINDNXT   ;get te next file name.
EC32   C3 21 EC               JMP   CHGNAM1   ;and continue.
EC35                             ; 
EC35                             ;   Update a files attributes. The procedure is to search for
EC35                             ; every file with the same name as shown in fcb (ignoring bit 7)
EC35                             ; and then to update it (which includes bit 7). No other changes
EC35                             ; are made.
EC35                             ; 
EC35   0E 0C        SAVEATTR:   MVI   C,12   ;match first 12 bytes.
EC37   CD 12 EB               CALL   FINDFST   ;look for first filename.
EC3A   CD EF E9     SAVATR1:   CALL   CKFILPOS   ;was one found?
EC3D   C8                     RZ      ;nope, we must be done.
EC3E   0E 00                  MVI   C,0   ;yes, update the first 12 bytes now.
EC40   1E 0C                  MVI   E,12   
EC42   CD FB EB               CALL   UPDATE   ;update filename and write directory.
EC45   CD 27 EB               CALL   FINDNXT   ;and get the next file.
EC48   C3 3A EC               JMP   SAVATR1   ;then continue until done.
EC4B                             ; 
EC4B                             ;  Open a file (name specified in fcb).
EC4B                             ; 
EC4B   0E 0F        OPENIT:   MVI   C,15   ;compare the first 15 bytes.
EC4D   CD 12 EB               CALL   FINDFST   ;get the first one in directory.
EC50   CD EF E9               CALL   CKFILPOS   ;any at all?
EC53   C8                     RZ      
EC54   CD A0 E8     OPENIT1:   CALL   SETEXT   ;point to extent byte within users fcb.
EC57   7E                     MOV   A,M   ;and get it.
EC58   F5                     PUSH   PSW   ;save it and address.
EC59   E5                     PUSH   H   
EC5A   CD 58 E9               CALL   FCB2HL   ;point to fcb in directory.
EC5D   EB                     XCHG      
EC5E   2A 3D E7               LHLD   PARAMS   ;this is the users copy.
EC61   0E 20                  MVI   C,32   ;move it into users space.
EC63   D5                     PUSH   D   
EC64   CD 49 E7               CALL   DE2HL   
EC67   CD 72 E9               CALL   SETS2B7   ;set bit 7 in "s2" byte (unmodified).
EC6A   D1                     POP   D   ;now get the extent byte from this fcb.
EC6B   21 0C 00               LXI   H,12   
EC6E   19                     DAD   D   
EC6F   4E                     MOV   C,M   ;into (C).
EC70   21 0F 00               LXI   H,15   ;now get the record count byte into (B).
EC73   19                     DAD   D   
EC74   46                     MOV   B,M   
EC75   E1                     POP   H   ;keep the same extent as the user had originally.
EC76   F1                     POP   PSW   
EC77   77                     MOV   M,A   
EC78   79                     MOV   A,C   ;is it the same as in the directory fcb?
EC79   BE                     CMP   M   
EC7A   78                     MOV   A,B   ;if yes, then use the same record count.
EC7B   CA 85 EC               JZ   OPENIT2   
EC7E   3E 00                  MVI   A,0   ;if the user specified an extent greater than
EC80   DA 85 EC               JC   OPENIT2   ;the one in the directory, then set record count to 0.
EC83   3E 80                  MVI   A,128   ;otherwise set to maximum.
EC85   2A 3D E7     OPENIT2:   LHLD   PARAMS   ;set record count in users fcb to (A).
EC88   11 0F 00               LXI   D,15   
EC8B   19                     DAD   D   ;compute relative position.
EC8C   77                     MOV   M,A   ;and set the record count.
EC8D   C9                     RET      
EC8E                             ; 
EC8E                             ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
EC8E                             ; point to a zero value (16 bit).
EC8E                             ;   Return with zero flag set it (DE) was moved. Registers (DE)
EC8E                             ; and (HL) are not changed. However (A) is.
EC8E                             ; 
EC8E   7E           MOVEWORD:   MOV   A,M   ;check for a zero word.
EC8F   23                     INX   H   
EC90   B6                     ORA   M   ;both bytes zero?
EC91   2B                     DCX   H   
EC92   C0                     RNZ      ;nope, just return.
EC93   1A                     LDAX   D   ;yes, move two bytes from (DE) into
EC94   77                     MOV   M,A   ;this zero space.
EC95   13                     INX   D   
EC96   23                     INX   H   
EC97   1A                     LDAX   D   
EC98   77                     MOV   M,A   
EC99   1B                     DCX   D   ;don't disturb these registers.
EC9A   2B                     DCX   H   
EC9B   C9                     RET      
EC9C                             ; 
EC9C                             ;   Get here to close a file specified by (fcb).
EC9C                             ; 
EC9C   AF           CLOSEIT:   XRA   A   ;clear status and file position bytes.
EC9D   32 3F E7               STA   STATUS   
ECA0   32 E4 F1               STA   FILEPOS   
ECA3   32 E5 F1               STA   FILEPOS+1   
ECA6   CD 18 E9               CALL   GETWPRT   ;get write protect bit for this drive.
ECA9   C0                     RNZ      ;just return if it is set.
ECAA   CD 63 E9               CALL   GETS2   ;else get the "s2" byte.
ECAD   E6 80                  ANI   80H   ;and look at bit 7 (file unmodified?).
ECAF   C0                     RNZ      ;just return if set.
ECB0   0E 0F                  MVI   C,15   ;else look up this file in directory.
ECB2   CD 12 EB               CALL   FINDFST   
ECB5   CD EF E9               CALL   CKFILPOS   ;was it found?
ECB8   C8                     RZ      ;just return if not.
ECB9   01 10 00               LXI   B,16   ;set (HL) pointing to records used section.
ECBC   CD 58 E9               CALL   FCB2HL   
ECBF   09                     DAD   B   
ECC0   EB                     XCHG      
ECC1   2A 3D E7               LHLD   PARAMS   ;do the same for users specified fcb.
ECC4   09                     DAD   B   
ECC5   0E 10                  MVI   C,16   ;this many bytes are present in this extent.
ECC7   3A D7 F1     CLOSEIT1:   LDA   BIGDISK   ;8 or 16 bit record numbers?
ECCA   B7                     ORA   A   
ECCB   CA E2 EC               JZ   CLOSEIT4   
ECCE   7E                     MOV   A,M   ;just 8 bit. Get one from users fcb.
ECCF   B7                     ORA   A   
ECD0   1A                     LDAX   D   ;now get one from directory fcb.
ECD1   C2 D5 EC               JNZ   CLOSEIT2   
ECD4   77                     MOV   M,A   ;users byte was zero. Update from directory.
ECD5   B7           CLOSEIT2:   ORA   A   
ECD6   C2 DB EC               JNZ   CLOSEIT3   
ECD9   7E                     MOV   A,M   ;directories byte was zero, update from users fcb.
ECDA   12                     STAX   D   
ECDB   BE           CLOSEIT3:   CMP   M   ;if neither one of these bytes were zero,
ECDC   C2 19 ED               JNZ   CLOSEIT7   ;then close error if they are not the same.
ECDF   C3 F7 EC               JMP   CLOSEIT5   ;ok so far, get to next byte in fcbs.
ECE2   CD 8E EC     CLOSEIT4:   CALL   MOVEWORD   ;update users fcb if it is zero.
ECE5   EB                     XCHG      
ECE6   CD 8E EC               CALL   MOVEWORD   ;update directories fcb if it is zero.
ECE9   EB                     XCHG      
ECEA   1A                     LDAX   D   ;if these two values are no different,
ECEB   BE                     CMP   M   ;then a close error occured.
ECEC   C2 19 ED               JNZ   CLOSEIT7   
ECEF   13                     INX   D   ;check second byte.
ECF0   23                     INX   H   
ECF1   1A                     LDAX   D   
ECF2   BE                     CMP   M   
ECF3   C2 19 ED               JNZ   CLOSEIT7   
ECF6   0D                     DCR   C   ;remember 16 bit values.
ECF7   13           CLOSEIT5:   INX   D   ;bump to next item in table.
ECF8   23                     INX   H   
ECF9   0D                     DCR   C   ;there are 16 entries only.
ECFA   C2 C7 EC               JNZ   CLOSEIT1   ;continue if more to do.
ECFD   01 EC FF               LXI   B,0FFECH   ;backup 20 places (extent byte).
ED00   09                     DAD   B   
ED01   EB                     XCHG      
ED02   09                     DAD   B   
ED03   1A                     LDAX   D   
ED04   BE                     CMP   M   ;directory's extent already greater than the
ED05   DA 11 ED               JC   CLOSEIT6   ;users extent?
ED08   77                     MOV   M,A   ;no, update directory extent.
ED09   01 03 00               LXI   B,3   ;and update the record count byte in
ED0C   09                     DAD   B   ;directories fcb.
ED0D   EB                     XCHG      
ED0E   09                     DAD   B   
ED0F   7E                     MOV   A,M   ;get from user.
ED10   12                     STAX   D   ;and put in directory.
ED11   3E FF        CLOSEIT6:   MVI   A,0FFH   ;set "was open and is now closed" byte.
ED13   32 CC F1               STA   CLOSEFLG   
ED16   C3 0A EC               JMP   UPDATE1   ;update the directory now.
ED19   21 3F E7     CLOSEIT7:   LXI   H,STATUS   ;set return status and then return.
ED1C   35                     DCR   M   
ED1D   C9                     RET      
ED1E                             ; 
ED1E                             ;   Routine to get the next empty space in the directory. It
ED1E                             ; will then be cleared for use.
ED1E                             ; 
ED1E   CD 4E E9     GETEMPTY:   CALL   CHKWPRT   ;make sure disk is not write protected.
ED21   2A 3D E7               LHLD   PARAMS   ;save current parameters (fcb).
ED24   E5                     PUSH   H   
ED25   21 A6 F1               LXI   H,EMPTYFCB   ;use special one for empty space.
ED28   22 3D E7               SHLD   PARAMS   
ED2B   0E 01                  MVI   C,1   ;search for first empty spot in directory.
ED2D   CD 12 EB               CALL   FINDFST   ;(* only check first byte *)
ED30   CD EF E9               CALL   CKFILPOS   ;none?
ED33   E1                     POP   H   
ED34   22 3D E7               SHLD   PARAMS   ;restore original fcb address.
ED37   C8                     RZ      ;return if no more space.
ED38   EB                     XCHG      
ED39   21 0F 00               LXI   H,15   ;point to number of records for this file.
ED3C   19                     DAD   D   
ED3D   0E 11                  MVI   C,17   ;and clear all of this space.
ED3F   AF                     XRA   A   
ED40   77           GETMT1:   MOV   M,A   
ED41   23                     INX   H   
ED42   0D                     DCR   C   
ED43   C2 40 ED               JNZ   GETMT1   
ED46   21 0D 00               LXI   H,13   ;clear the "s1" byte also.
ED49   19                     DAD   D   
ED4A   77                     MOV   M,A   
ED4B   CD 86 E9               CALL   CHKNMBR   ;keep (SCRATCH1) within bounds.
ED4E   CD F7 EB               CALL   FCBSET   ;write out this fcb entry to directory.
ED51   C3 72 E9               JMP   SETS2B7   ;set "s2" byte bit 7 (unmodified at present).
ED54                             ; 
ED54                             ;   Routine to close the current extent and open the next one
ED54                             ; for reading.
ED54                             ; 
ED54   AF           GETNEXT:   XRA   A   
ED55   32 CC F1               STA   CLOSEFLG   ;clear close flag.
ED58   CD 9C EC               CALL   CLOSEIT   ;close this extent.
ED5B   CD EF E9               CALL   CKFILPOS   
ED5E   C8                     RZ      ;not there???
ED5F   2A 3D E7               LHLD   PARAMS   ;get extent byte.
ED62   01 0C 00               LXI   B,12   
ED65   09                     DAD   B   
ED66   7E                     MOV   A,M   ;and increment it.
ED67   3C                     INR   A   
ED68   E6 1F                  ANI   1FH   ;keep within range 0-31.
ED6A   77                     MOV   M,A   
ED6B   CA 7D ED               JZ   GTNEXT1   ;overflow?
ED6E   47                     MOV   B,A   ;mask extent byte.
ED6F   3A BF F1               LDA   EXTMASK   
ED72   A0                     ANA   B   
ED73   21 CC F1               LXI   H,CLOSEFLG   ;check close flag (0ffh is ok).
ED76   A6                     ANA   M   
ED77   CA 88 ED               JZ   GTNEXT2   ;if zero, we must read in next extent.
ED7A   C3 A6 ED               JMP   GTNEXT3   ;else, it is already in memory.
ED7D   01 02 00     GTNEXT1:   LXI   B,2   ;Point to the "s2" byte.
ED80   09                     DAD   B   
ED81   34                     INR   M   ;and bump it.
ED82   7E                     MOV   A,M   ;too many extents?
ED83   E6 0F                  ANI   0FH   
ED85   CA B0 ED               JZ   GTNEXT5   ;yes, set error code.
ED88                             ; 
ED88                             ;   Get here to open the next extent.
ED88                             ; 
ED88   0E 0F        GTNEXT2:   MVI   C,15   ;set to check first 15 bytes of fcb.
ED8A   CD 12 EB               CALL   FINDFST   ;find the first one.
ED8D   CD EF E9               CALL   CKFILPOS   ;none available?
ED90   C2 A6 ED               JNZ   GTNEXT3   
ED93   3A CD F1               LDA   RDWRTFLG   ;no extent present. Can we open an empty one?
ED96   3C                     INR   A   ;0ffh means reading (so not possible).
ED97   CA B0 ED               JZ   GTNEXT5   ;or an error.
ED9A   CD 1E ED               CALL   GETEMPTY   ;we are writing, get an empty entry.
ED9D   CD EF E9               CALL   CKFILPOS   ;none?
EDA0   CA B0 ED               JZ   GTNEXT5   ;error if true.
EDA3   C3 A9 ED               JMP   GTNEXT4   ;else we are almost done.
EDA6   CD 54 EC     GTNEXT3:   CALL   OPENIT1   ;open this extent.
EDA9   CD B5 E8     GTNEXT4:   CALL   STRDATA   ;move in updated data (rec #, extent #, etc.)
EDAC   AF                     XRA   A   ;clear status and return.
EDAD   C3 FB E6               JMP   SETSTAT   
EDB0                             ; 
EDB0                             ;   Error in extending the file. Too many extents were needed
EDB0                             ; or not enough space on the disk.
EDB0                             ; 
EDB0   CD FF E6     GTNEXT5:   CALL   IOERR1   ;set error code, clear bit 7 of "s2"
EDB3   C3 72 E9               JMP   SETS2B7   ;so this is not written on a close.
EDB6                             ; 
EDB6                             ;   Read a sequential file.
EDB6                             ; 
EDB6   3E 01        RDSEQ:    MVI   A,1   ;set sequential access mode.
EDB8   32 CF F1               STA   MODE   
EDBB   3E FF        RDSEQ1:   MVI   A,0FFH   ;don't allow reading unwritten space.
EDBD   32 CD F1               STA   RDWRTFLG   
EDC0   CD B5 E8               CALL   STRDATA   ;put rec# and ext# into fcb.
EDC3   3A DD F1               LDA   SAVNREC   ;get next record to read.
EDC6   21 DB F1               LXI   H,SAVNXT   ;get number of records in extent.
EDC9   BE                     CMP   M   ;within this extent?
EDCA   DA E0 ED               JC   RDSEQ2   
EDCD   FE 80                  CPI   128   ;no. Is this extent fully used?
EDCF   C2 F5 ED               JNZ   RDSEQ3   ;no. End-of-file.
EDD2   CD 54 ED               CALL   GETNEXT   ;yes, open the next one.
EDD5   AF                     XRA   A   ;reset next record to read.
EDD6   32 DD F1               STA   SAVNREC   
EDD9   3A 3F E7               LDA   STATUS   ;check on open, successful?
EDDC   B7                     ORA   A   
EDDD   C2 F5 ED               JNZ   RDSEQ3   ;no, error.
EDE0   CD 71 E8     RDSEQ2:   CALL   COMBLK   ;ok. compute block number to read.
EDE3   CD 7E E8               CALL   CHKBLK   ;check it. Within bounds?
EDE6   CA F5 ED               JZ   RDSEQ3   ;no, error.
EDE9   CD 84 E8               CALL   LOGICAL   ;convert (BLKNMBR) to logical sector (128 byte).
EDEC   CD CB E7               CALL   TRKSEC1   ;set the track and sector for this block #.
EDEF   CD AC E7               CALL   DOREAD   ;and read it.
EDF2   C3 CC E8               JMP   SETNREC   ;and set the next record to be accessed.
EDF5                             ; 
EDF5                             ;   Read error occured. Set status and return.
EDF5                             ; 
EDF5   C3 FF E6     RDSEQ3:   JMP   IOERR1   
EDF8                             ; 
EDF8                             ;   Write the next sequential record.
EDF8                             ; 
EDF8   3E 01        WTSEQ:    MVI   A,1   ;set sequential access mode.
EDFA   32 CF F1               STA   MODE   
EDFD   3E 00        WTSEQ1:   MVI   A,0   ;allow an addition empty extent to be opened.
EDFF   32 CD F1               STA   RDWRTFLG   
EE02   CD 4E E9               CALL   CHKWPRT   ;check write protect status.
EE05   2A 3D E7               LHLD   PARAMS   
EE08   CD 41 E9               CALL   CKROF1   ;check for read only file, (HL) already set to fcb.
EE0B   CD B5 E8               CALL   STRDATA   ;put updated data into fcb.
EE0E   3A DD F1               LDA   SAVNREC   ;get record number to write.
EE11   FE 80                  CPI   128   ;within range?
EE13   D2 FF E6               JNC   IOERR1   ;no, error(?).
EE16   CD 71 E8               CALL   COMBLK   ;compute block number.
EE19   CD 7E E8               CALL   CHKBLK   ;check number.
EE1C   0E 00                  MVI   C,0   ;is there one to write to?
EE1E   C2 68 EE               JNZ   WTSEQ6   ;yes, go do it.
EE21   CD 38 E8               CALL   GETBLOCK   ;get next block number within fcb to use.
EE24   32 D1 F1               STA   RELBLOCK   ;and save.
EE27   01 00 00               LXI   B,0   ;start looking for space from the start
EE2A   B7                     ORA   A   ;if none allocated as yet.
EE2B   CA 35 EE               JZ   WTSEQ2   
EE2E   4F                     MOV   C,A   ;extract previous block number from fcb
EE2F   0B                     DCX   B   ;so we can be closest to it.
EE30   CD 58 E8               CALL   EXTBLK   
EE33   44                     MOV   B,H   
EE34   4D                     MOV   C,L   
EE35   CD B8 EB     WTSEQ2:   CALL   FNDSPACE   ;find the next empty block nearest number (BC).
EE38   7D                     MOV   A,L   ;check for a zero number.
EE39   B4                     ORA   H   
EE3A   C2 42 EE               JNZ   WTSEQ3   
EE3D   3E 02                  MVI   A,2   ;no more space?
EE3F   C3 FB E6               JMP   SETSTAT   
EE42   22 DF F1     WTSEQ3:   SHLD   BLKNMBR   ;save block number to access.
EE45   EB                     XCHG      ;put block number into (DE).
EE46   2A 3D E7               LHLD   PARAMS   ;now we must update the fcb for this
EE49   01 10 00               LXI   B,16   ;newly allocated block.
EE4C   09                     DAD   B   
EE4D   3A D7 F1               LDA   BIGDISK   ;8 or 16 bit block numbers?
EE50   B7                     ORA   A   
EE51   3A D1 F1               LDA   RELBLOCK   ;(* update this entry *)
EE54   CA 5E EE               JZ   WTSEQ4   ;zero means 16 bit ones.
EE57   CD 5E E9               CALL   ADDA2HL   ;(HL)=(HL)+(A)
EE5A   73                     MOV   M,E   ;store new block number.
EE5B   C3 66 EE               JMP   WTSEQ5   
EE5E   4F           WTSEQ4:   MOV   C,A   ;compute spot in this 16 bit table.
EE5F   06 00                  MVI   B,0   
EE61   09                     DAD   B   
EE62   09                     DAD   B   
EE63   73                     MOV   M,E   ;stuff block number (DE) there.
EE64   23                     INX   H   
EE65   72                     MOV   M,D   
EE66   0E 02        WTSEQ5:   MVI   C,2   ;set (C) to indicate writing to un-used disk space.
EE68   3A 3F E7     WTSEQ6:   LDA   STATUS   ;are we ok so far?
EE6B   B7                     ORA   A   
EE6C   C0                     RNZ      
EE6D   C5                     PUSH   B   ;yes, save write flag for bios (register C).
EE6E   CD 84 E8               CALL   LOGICAL   ;convert (BLKNMBR) over to loical sectors.
EE71   3A CF F1               LDA   MODE   ;get access mode flag (1=sequential,
EE74   3D                     DCR   A   ;0=random, 2=special?).
EE75   3D                     DCR   A   
EE76   C2 B5 EE               JNZ   WTSEQ9   
EE79                             ; 
EE79                             ;   Special random i/o from function #40. Maybe for M/PM, but the
EE79                             ; current block, if it has not been written to, will be zeroed
EE79                             ; out and then written (reason?).
EE79                             ; 
EE79   C1                     POP   B   
EE7A   C5                     PUSH   B   
EE7B   79                     MOV   A,C   ;get write status flag (2=writing unused space).
EE7C   3D                     DCR   A   
EE7D   3D                     DCR   A   
EE7E   C2 B5 EE               JNZ   WTSEQ9   
EE81   E5                     PUSH   H   
EE82   2A B3 F1               LHLD   DIRBUF   ;zero out the directory buffer.
EE85   57                     MOV   D,A   ;note that (A) is zero here.
EE86   77           WTSEQ7:   MOV   M,A   
EE87   23                     INX   H   
EE88   14                     INR   D   ;do 128 bytes.
EE89   F2 86 EE               JP   WTSEQ7   
EE8C   CD DA E9               CALL   DIRDMA   ;tell the bios the dma address for directory access.
EE8F   2A E1 F1               LHLD   LOGSECT   ;get sector that starts current block.
EE92   0E 02                  MVI   C,2   ;set "writing to unused space" flag.
EE94   22 DF F1     WTSEQ8:   SHLD   BLKNMBR   ;save sector to write.
EE97   C5                     PUSH   B   
EE98   CD CB E7               CALL   TRKSEC1   ;determine its track and sector numbers.
EE9B   C1                     POP   B   
EE9C   CD B2 E7               CALL   DOWRITE   ;now write out 128 bytes of zeros.
EE9F   2A DF F1               LHLD   BLKNMBR   ;get sector number.
EEA2   0E 00                  MVI   C,0   ;set normal write flag.
EEA4   3A BE F1               LDA   BLKMASK   ;determine if we have written the entire
EEA7   47                     MOV   B,A   ;physical block.
EEA8   A5                     ANA   L   
EEA9   B8                     CMP   B   
EEAA   23                     INX   H   ;prepare for the next one.
EEAB   C2 94 EE               JNZ   WTSEQ8   ;continue until (BLKMASK+1) sectors written.
EEAE   E1                     POP   H   ;reset next sector number.
EEAF   22 DF F1               SHLD   BLKNMBR   
EEB2   CD D4 E9               CALL   DEFDMA   ;and reset dma address.
EEB5                             ; 
EEB5                             ;   Normal disk write. Set the desired track and sector then
EEB5                             ; do the actual write.
EEB5                             ; 
EEB5   CD CB E7     WTSEQ9:   CALL   TRKSEC1   ;determine track and sector for this write.
EEB8   C1                     POP   B   ;get write status flag.
EEB9   C5                     PUSH   B   
EEBA   CD B2 E7               CALL   DOWRITE   ;and write this out.
EEBD   C1                     POP   B   
EEBE   3A DD F1               LDA   SAVNREC   ;get number of records in file.
EEC1   21 DB F1               LXI   H,SAVNXT   ;get last record written.
EEC4   BE                     CMP   M   
EEC5   DA CC EE               JC   WTSEQ10   
EEC8   77                     MOV   M,A   ;we have to update record count.
EEC9   34                     INR   M   
EECA   0E 02                  MVI   C,2   
EECC                             ; 
EECC                             ;*   This area has been patched to correct disk update problem
EECC                             ;* when using blocking and de-blocking in the BIOS.
EECC                             ; 
EECC   00           WTSEQ10:   NOP      ;was "dcr c"
EECD   00                     NOP      ;was "dcr c"
EECE   21 00 00               LXI   H,0   ;was "jnz wtseq99"
EED1                             ; 
EED1                             ; *   End of patch.
EED1                             ; 
EED1   F5                     PUSH   PSW   
EED2   CD 63 E9               CALL   GETS2   ;set "extent written to" flag.
EED5   E6 7F                  ANI   7FH   ;(* clear bit 7 *)
EED7   77                     MOV   M,A   
EED8   F1                     POP   PSW   ;get record count for this extent.
EED9   FE 7F        WTSEQ99:   CPI   127   ;is it full?
EEDB   C2 FA EE               JNZ   WTSEQ12   
EEDE   3A CF F1               LDA   MODE   ;yes, are we in sequential mode?
EEE1   FE 01                  CPI   1   
EEE3   C2 FA EE               JNZ   WTSEQ12   
EEE6   CD CC E8               CALL   SETNREC   ;yes, set next record number.
EEE9   CD 54 ED               CALL   GETNEXT   ;and get next empty space in directory.
EEEC   21 3F E7               LXI   H,STATUS   ;ok?
EEEF   7E                     MOV   A,M   
EEF0   B7                     ORA   A   
EEF1   C2 F8 EE               JNZ   WTSEQ11   
EEF4   3D                     DCR   A   ;yes, set record count to -1.
EEF5   32 DD F1               STA   SAVNREC   
EEF8   36 00        WTSEQ11:   MVI   M,0   ;clear status.
EEFA   C3 CC E8     WTSEQ12:   JMP   SETNREC   ;set next record to access.
EEFD                             ; 
EEFD                             ;   For random i/o, set the fcb for the desired record number
EEFD                             ; based on the "r0,r1,r2" bytes. These bytes in the fcb are
EEFD                             ; used as follows:
EEFD                             ; 
EEFD                             ;       fcb+35            fcb+34            fcb+33
EEFD                             ;  |     "r-2"      |      "r-1"      |      "r-0"     |
EEFD                             ;  |7             0 | 7             0 | 7             0|
EEFD                             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
EEFD                             ;  |    overflow   | | extra |  extent   |   record #  |
EEFD                             ;  | ______________| |_extent|__number___|_____________|
EEFD                             ;                     also "s2"
EEFD                             ; 
EEFD                             ;   On entry, register (C) contains 0ffh if this is a read
EEFD                             ; and thus we can not access unwritten disk space. Otherwise,
EEFD                             ; another extent will be opened (for writing) if required.
EEFD                             ; 
EEFD   AF           POSITION:   XRA   A   ;set random i/o flag.
EEFE   32 CF F1               STA   MODE   
EF01                             ; 
EF01                             ;   Special entry (function #40). M/PM ?
EF01                             ; 
EF01   C5           POSITN1:   PUSH   B   ;save read/write flag.
EF02   2A 3D E7               LHLD   PARAMS   ;get address of fcb.
EF05   EB                     XCHG      
EF06   21 21 00               LXI   H,33   ;now get byte "r0".
EF09   19                     DAD   D   
EF0A   7E                     MOV   A,M   
EF0B   E6 7F                  ANI   7FH   ;keep bits 0-6 for the record number to access.
EF0D   F5                     PUSH   PSW   
EF0E   7E                     MOV   A,M   ;now get bit 7 of "r0" and bits 0-3 of "r1".
EF0F   17                     RAL      
EF10   23                     INX   H   
EF11   7E                     MOV   A,M   
EF12   17                     RAL      
EF13   E6 1F                  ANI   1FH   ;and save this in bits 0-4 of (C).
EF15   4F                     MOV   C,A   ;this is the extent byte.
EF16   7E                     MOV   A,M   ;now get the extra extent byte.
EF17   1F                     RAR      
EF18   1F                     RAR      
EF19   1F                     RAR      
EF1A   1F                     RAR      
EF1B   E6 0F                  ANI   0FH   
EF1D   47                     MOV   B,A   ;and save it in (B).
EF1E   F1                     POP   PSW   ;get record number back to (A).
EF1F   23                     INX   H   ;check overflow byte "r2".
EF20   6E                     MOV   L,M   
EF21   2C                     INR   L   
EF22   2D                     DCR   L   
EF23   2E 06                  MVI   L,6   ;prepare for error.
EF25   C2 85 EF               JNZ   POSITN5   ;out of disk space error.
EF28   21 20 00               LXI   H,32   ;store record number into fcb.
EF2B   19                     DAD   D   
EF2C   77                     MOV   M,A   
EF2D   21 0C 00               LXI   H,12   ;and now check the extent byte.
EF30   19                     DAD   D   
EF31   79                     MOV   A,C   
EF32   96                     SUB   M   ;same extent as before?
EF33   C2 41 EF               JNZ   POSITN2   
EF36   21 0E 00               LXI   H,14   ;yes, check extra extent byte "s2" also.
EF39   19                     DAD   D   
EF3A   78                     MOV   A,B   
EF3B   96                     SUB   M   
EF3C   E6 7F                  ANI   7FH   
EF3E   CA 79 EF               JZ   POSITN3   ;same, we are almost done then.
EF41                             ; 
EF41                             ;  Get here when another extent is required.
EF41                             ; 
EF41   C5           POSITN2:   PUSH   B   
EF42   D5                     PUSH   D   
EF43   CD 9C EC               CALL   CLOSEIT   ;close current extent.
EF46   D1                     POP   D   
EF47   C1                     POP   B   
EF48   2E 03                  MVI   L,3   ;prepare for error.
EF4A   3A 3F E7               LDA   STATUS   
EF4D   3C                     INR   A   
EF4E   CA 7E EF               JZ   POSITN4   ;close error.
EF51   21 0C 00               LXI   H,12   ;put desired extent into fcb now.
EF54   19                     DAD   D   
EF55   71                     MOV   M,C   
EF56   21 0E 00               LXI   H,14   ;and store extra extent byte "s2".
EF59   19                     DAD   D   
EF5A   70                     MOV   M,B   
EF5B   CD 4B EC               CALL   OPENIT   ;try and get this extent.
EF5E   3A 3F E7               LDA   STATUS   ;was it there?
EF61   3C                     INR   A   
EF62   C2 79 EF               JNZ   POSITN3   
EF65   C1                     POP   B   ;no. can we create a new one (writing?).
EF66   C5                     PUSH   B   
EF67   2E 04                  MVI   L,4   ;prepare for error.
EF69   0C                     INR   C   
EF6A   CA 7E EF               JZ   POSITN4   ;nope, reading unwritten space error.
EF6D   CD 1E ED               CALL   GETEMPTY   ;yes we can, try to find space.
EF70   2E 05                  MVI   L,5   ;prepare for error.
EF72   3A 3F E7               LDA   STATUS   
EF75   3C                     INR   A   
EF76   CA 7E EF               JZ   POSITN4   ;out of space?
EF79                             ; 
EF79                             ;   Normal return location. Clear error code and return.
EF79                             ; 
EF79   C1           POSITN3:   POP   B   ;restore stack.
EF7A   AF                     XRA   A   ;and clear error code byte.
EF7B   C3 FB E6               JMP   SETSTAT   
EF7E                             ; 
EF7E                             ;   Error. Set the "s2" byte to indicate this (why?).
EF7E                             ; 
EF7E   E5           POSITN4:   PUSH   H   
EF7F   CD 63 E9               CALL   GETS2   
EF82   36 C0                  MVI   M,0C0H   
EF84   E1                     POP   H   
EF85                             ; 
EF85                             ;   Return with error code (presently in L).
EF85                             ; 
EF85   C1           POSITN5:   POP   B   
EF86   7D                     MOV   A,L   ;get error code.
EF87   32 3F E7               STA   STATUS   
EF8A   C3 72 E9               JMP   SETS2B7   
EF8D                             ; 
EF8D                             ;   Read a random record.
EF8D                             ; 
EF8D   0E FF        READRAN:   MVI   C,0FFH   ;set "read" status.
EF8F   CD FD EE               CALL   POSITION   ;position the file to proper record.
EF92   CC BB ED               CZ   RDSEQ1   ;and read it as usual (if no errors).
EF95   C9                     RET      
EF96                             ; 
EF96                             ;   Write to a random record.
EF96                             ; 
EF96   0E 00        WRITERAN:   MVI   C,0   ;set "writing" flag.
EF98   CD FD EE               CALL   POSITION   ;position the file to proper record.
EF9B   CC FD ED               CZ   WTSEQ1   ;and write as usual (if no errors).
EF9E   C9                     RET      
EF9F                             ; 
EF9F                             ;   Compute the random record number. Enter with (HL) pointing
EF9F                             ; to a fcb an (DE) contains a relative location of a record
EF9F                             ; number. On exit, (C) contains the "r0" byte, (B) the "r1"
EF9F                             ; byte, and (A) the "r2" byte.
EF9F                             ; 
EF9F                             ;   On return, the zero flag is set if the record is within
EF9F                             ; bounds. Otherwise, an overflow occured.
EF9F                             ; 
EF9F   EB           COMPRAND:   XCHG      ;save fcb pointer in (DE).
EFA0   19                     DAD   D   ;compute relative position of record #.
EFA1   4E                     MOV   C,M   ;get record number into (BC).
EFA2   06 00                  MVI   B,0   
EFA4   21 0C 00               LXI   H,12   ;now get extent.
EFA7   19                     DAD   D   
EFA8   7E                     MOV   A,M   ;compute (BC)=(record #)+(extent)*128.
EFA9   0F                     RRC      ;move lower bit into bit 7.
EFAA   E6 80                  ANI   80H   ;and ignore all other bits.
EFAC   81                     ADD   C   ;add to our record number.
EFAD   4F                     MOV   C,A   
EFAE   3E 00                  MVI   A,0   ;take care of any carry.
EFB0   88                     ADC   B   
EFB1   47                     MOV   B,A   
EFB2   7E                     MOV   A,M   ;now get the upper bits of extent into
EFB3   0F                     RRC      ;bit positions 0-3.
EFB4   E6 0F                  ANI   0FH   ;and ignore all others.
EFB6   80                     ADD   B   ;add this in to "r1" byte.
EFB7   47                     MOV   B,A   
EFB8   21 0E 00               LXI   H,14   ;get the "s2" byte (extra extent).
EFBB   19                     DAD   D   
EFBC   7E                     MOV   A,M   
EFBD   87                     ADD   A   ;and shift it left 4 bits (bits 4-7).
EFBE   87                     ADD   A   
EFBF   87                     ADD   A   
EFC0   87                     ADD   A   
EFC1   F5                     PUSH   PSW   ;save carry flag (bit 0 of flag byte).
EFC2   80                     ADD   B   ;now add extra extent into "r1".
EFC3   47                     MOV   B,A   
EFC4   F5                     PUSH   PSW   ;and save carry (overflow byte "r2").
EFC5   E1                     POP   H   ;bit 0 of (L) is the overflow indicator.
EFC6   7D                     MOV   A,L   
EFC7   E1                     POP   H   ;and same for first carry flag.
EFC8   B5                     ORA   L   ;either one of these set?
EFC9   E6 01                  ANI   01H   ;only check the carry flags.
EFCB   C9                     RET      
EFCC                             ; 
EFCC                             ;   Routine to setup the fcb (bytes "r0", "r1", "r2") to
EFCC                             ; reflect the last record used for a random (or other) file.
EFCC                             ; This reads the directory and looks at all extents computing
EFCC                             ; the largerst record number for each and keeping the maximum
EFCC                             ; value only. Then "r0", "r1", and "r2" will reflect this
EFCC                             ; maximum record number. This is used to compute the space used
EFCC                             ; by a random file.
EFCC                             ; 
EFCC   0E 0C        RANSIZE:   MVI   C,12   ;look thru directory for first entry with
EFCE   CD 12 EB               CALL   FINDFST   ;this name.
EFD1   2A 3D E7               LHLD   PARAMS   ;zero out the "r0, r1, r2" bytes.
EFD4   11 21 00               LXI   D,33   
EFD7   19                     DAD   D   
EFD8   E5                     PUSH   H   
EFD9   72                     MOV   M,D   ;note that (D)=0.
EFDA   23                     INX   H   
EFDB   72                     MOV   M,D   
EFDC   23                     INX   H   
EFDD   72                     MOV   M,D   
EFDE   CD EF E9     RANSIZ1:   CALL   CKFILPOS   ;is there an extent to process?
EFE1   CA 06 F0               JZ   RANSIZ3   ;no, we are done.
EFE4   CD 58 E9               CALL   FCB2HL   ;set (HL) pointing to proper fcb in dir.
EFE7   11 0F 00               LXI   D,15   ;point to last record in extent.
EFEA   CD 9F EF               CALL   COMPRAND   ;and compute random parameters.
EFED   E1                     POP   H   
EFEE   E5                     PUSH   H   ;now check these values against those
EFEF   5F                     MOV   E,A   ;already in fcb.
EFF0   79                     MOV   A,C   ;the carry flag will be set if those
EFF1   96                     SUB   M   ;in the fcb represent a larger size than
EFF2   23                     INX   H   ;this extent does.
EFF3   78                     MOV   A,B   
EFF4   9E                     SBB   M   
EFF5   23                     INX   H   
EFF6   7B                     MOV   A,E   
EFF7   9E                     SBB   M   
EFF8   DA 00 F0               JC   RANSIZ2   
EFFB   73                     MOV   M,E   ;we found a larger (in size) extent.
EFFC   2B                     DCX   H   ;stuff these values into fcb.
EFFD   70                     MOV   M,B   
EFFE   2B                     DCX   H   
EFFF   71                     MOV   M,C   
F000   CD 27 EB     RANSIZ2:   CALL   FINDNXT   ;now get the next extent.
F003   C3 DE EF               JMP   RANSIZ1   ;continue til all done.
F006   E1           RANSIZ3:   POP   H   ;we are done, restore the stack and
F007   C9                     RET      ;return.
F008                             ; 
F008                             ;   Function to return the random record position of a given
F008                             ; file which has been read in sequential mode up to now.
F008                             ; 
F008   2A 3D E7     SETRAN:   LHLD   PARAMS   ;point to fcb.
F00B   11 20 00               LXI   D,32   ;and to last used record.
F00E   CD 9F EF               CALL   COMPRAND   ;compute random position.
F011   21 21 00               LXI   H,33   ;now stuff these values into fcb.
F014   19                     DAD   D   
F015   71                     MOV   M,C   ;move "r0".
F016   23                     INX   H   
F017   70                     MOV   M,B   ;and "r1".
F018   23                     INX   H   
F019   77                     MOV   M,A   ;and lastly "r2".
F01A   C9                     RET      
F01B                             ; 
F01B                             ;   This routine select the drive specified in (ACTIVE) and
F01B                             ; update the login vector and bitmap table if this drive was
F01B                             ; not already active.
F01B                             ; 
F01B   2A A9 F1     LOGINDRV:   LHLD   LOGIN   ;get the login vector.
F01E   3A 3C E7               LDA   ACTIVE   ;get the default drive.
F021   4F                     MOV   C,A   
F022   CD E4 E8               CALL   SHIFTR   ;position active bit for this drive
F025   E5                     PUSH   H   ;into bit 0.
F026   EB                     XCHG      
F027   CD 53 E7               CALL   SELECT   ;select this drive.
F02A   E1                     POP   H   
F02B   CC 41 E7               CZ   SLCTERR   ;valid drive?
F02E   7D                     MOV   A,L   ;is this a newly activated drive?
F02F   1F                     RAR      
F030   D8                     RC      
F031   2A A9 F1               LHLD   LOGIN   ;yes, update the login vector.
F034   4D                     MOV   C,L   
F035   44                     MOV   B,H   
F036   CD 05 E9               CALL   SETBIT   
F039   22 A9 F1               SHLD   LOGIN   ;and save.
F03C   C3 9D EA               JMP   BITMAP   ;now update the bitmap.
F03F                             ; 
F03F                             ;   Function to set the active disk number.
F03F                             ; 
F03F   3A D0 F1     SETDSK:   LDA   EPARAM   ;get parameter passed and see if this
F042   21 3C E7               LXI   H,ACTIVE   ;represents a change in drives.
F045   BE                     CMP   M   
F046   C8                     RZ      
F047   77                     MOV   M,A   ;yes it does, log it in.
F048   C3 1B F0               JMP   LOGINDRV   
F04B                             ; 
F04B                             ;   This is the "auto disk select" routine. The firsst byte
F04B                             ; of the fcb is examined for a drive specification. If non
F04B                             ; zero then the drive will be selected and loged in.
F04B                             ; 
F04B   3E FF        AUTOSEL:   MVI   A,0FFH   ;say "auto-select activated".
F04D   32 D8 F1               STA   AUTO   
F050   2A 3D E7               LHLD   PARAMS   ;get drive specified.
F053   7E                     MOV   A,M   
F054   E6 1F                  ANI   1FH   ;look at lower 5 bits.
F056   3D                     DCR   A   ;adjust for (1=A, 2=B) etc.
F057   32 D0 F1               STA   EPARAM   ;and save for the select routine.
F05A   FE 1E                  CPI   1EH   ;check for "no change" condition.
F05C   D2 6F F0               JNC   AUTOSL1   ;yes, don't change.
F05F   3A 3C E7               LDA   ACTIVE   ;we must change, save currently active
F062   32 D9 F1               STA   OLDDRV   ;drive.
F065   7E                     MOV   A,M   ;and save first byte of fcb also.
F066   32 DA F1               STA   AUTOFLAG   ;this must be non-zero.
F069   E6 E0                  ANI   0E0H   ;whats this for (bits 6,7 are used for
F06B   77                     MOV   M,A   ;something)?
F06C   CD 3F F0               CALL   SETDSK   ;select and log in this drive.
F06F   3A 3B E7     AUTOSL1:   LDA   USERNO   ;move user number into fcb.
F072   2A 3D E7               LHLD   PARAMS   ;(* upper half of first byte *)
F075   B6                     ORA   M   
F076   77                     MOV   M,A   
F077   C9                     RET      ;and return (all done).
F078                             ; 
F078                             ;   Function to return the current cp/m version number.
F078                             ; 
F078   3E 22        GETVER:   MVI   A,022h   ;version 2.2
F07A   C3 FB E6               JMP   SETSTAT   
F07D                             ; 
F07D                             ;   Function to reset the disk system.
F07D                             ; 
F07D   21 00 00     RSTDSK:   LXI   H,0   ;clear write protect status and log
F080   22 A7 F1               SHLD   WRTPRT   ;in vector.
F083   22 A9 F1               SHLD   LOGIN   
F086   AF                     XRA   A   ;select drive "A".
F087   32 3C E7               STA   ACTIVE   
F08A   21 80 80               LXI   H,TBUFF   ;setup default dma address.
F08D   22 AB F1               SHLD   USERDMA   
F090   CD D4 E9               CALL   DEFDMA   
F093   C3 1B F0               JMP   LOGINDRV   ;now log in drive "A".
F096                             ; 
F096                             ;   Function to open a specified file.
F096                             ; 
F096   CD 6C E9     OPENFIL:   CALL   CLEARS2   ;clear "s2" byte.
F099   CD 4B F0               CALL   AUTOSEL   ;select proper disk.
F09C   C3 4B EC               JMP   OPENIT   ;and open the file.
F09F                             ; 
F09F                             ;   Function to close a specified file.
F09F                             ; 
F09F   CD 4B F0     CLOSEFIL:   CALL   AUTOSEL   ;select proper disk.
F0A2   C3 9C EC               JMP   CLOSEIT   ;and close the file.
F0A5                             ; 
F0A5                             ;   Function to return the first occurence of a specified file
F0A5                             ; name. If the first byte of the fcb is "?" then the name will
F0A5                             ; not be checked (get the first entry no matter what).
F0A5                             ; 
F0A5   0E 00        GETFST:   MVI   C,0   ;prepare for special search.
F0A7   EB                     XCHG      
F0A8   7E                     MOV   A,M   ;is first byte a "?"?
F0A9   FE 3F                  CPI   "?"   
F0AB   CA BC F0               JZ   GETFST1   ;yes, just get very first entry (zero length match).
F0AE   CD A0 E8               CALL   SETEXT   ;get the extension byte from fcb.
F0B1   7E                     MOV   A,M   ;is it "?"? if yes, then we want
F0B2   FE 3F                  CPI   "?"   ;an entry with a specific "s2" byte.
F0B4   C4 6C E9               CNZ   CLEARS2   ;otherwise, look for a zero "s2" byte.
F0B7   CD 4B F0               CALL   AUTOSEL   ;select proper drive.
F0BA   0E 0F                  MVI   C,15   ;compare bytes 0-14 in fcb (12&13 excluded).
F0BC   CD 12 EB     GETFST1:   CALL   FINDFST   ;find an entry and then move it into
F0BF   C3 E3 E9               JMP   MOVEDIR   ;the users dma space.
F0C2                             ; 
F0C2                             ;   Function to return the next occurence of a file name.
F0C2                             ; 
F0C2   2A D3 F1     GETNXT:   LHLD   SAVEFCB   ;restore pointers. note that no
F0C5   22 3D E7               SHLD   PARAMS   ;other dbos calls are allowed.
F0C8   CD 4B F0               CALL   AUTOSEL   ;no error will be returned, but the
F0CB   CD 27 EB               CALL   FINDNXT   ;results will be wrong.
F0CE   C3 E3 E9               JMP   MOVEDIR   
F0D1                             ; 
F0D1                             ;   Function to delete a file by name.
F0D1                             ; 
F0D1   CD 4B F0     DELFILE:   CALL   AUTOSEL   ;select proper drive.
F0D4   CD 96 EB               CALL   ERAFILE   ;erase the file.
F0D7   C3 FB EA               JMP   STSTATUS   ;set status and return.
F0DA                             ; 
F0DA                             ;   Function to execute a sequential read of the specified
F0DA                             ; record number.
F0DA                             ; 
F0DA   CD 4B F0     READSEQ:   CALL   AUTOSEL   ;select proper drive then read.
F0DD   C3 B6 ED               JMP   RDSEQ   
F0E0                             ; 
F0E0                             ;   Function to write the net sequential record.
F0E0                             ; 
F0E0   CD 4B F0     WRTSEQ:   CALL   AUTOSEL   ;select proper drive then write.
F0E3   C3 F8 ED               JMP   WTSEQ   
F0E6                             ; 
F0E6                             ;   Create a file function.
F0E6                             ; 
F0E6   CD 6C E9     FCREATE:   CALL   CLEARS2   ;clear the "s2" byte on all creates.
F0E9   CD 4B F0               CALL   AUTOSEL   ;select proper drive and get the next
F0EC   C3 1E ED               JMP   GETEMPTY   ;empty directory space.
F0EF                             ; 
F0EF                             ;   Function to rename a file.
F0EF                             ; 
F0EF   CD 4B F0     RENFILE:   CALL   AUTOSEL   ;select proper drive and then switch
F0F2   CD 10 EC               CALL   CHGNAMES   ;file names.
F0F5   C3 FB EA               JMP   STSTATUS   
F0F8                             ; 
F0F8                             ;   Function to return the login vector.
F0F8                             ; 
F0F8   2A A9 F1     GETLOG:   LHLD   LOGIN   
F0FB   C3 23 F1               JMP   GETPRM1   
F0FE                             ; 
F0FE                             ;   Function to return the current disk assignment.
F0FE                             ; 
F0FE   3A 3C E7     GETCRNT:   LDA   ACTIVE   
F101   C3 FB E6               JMP   SETSTAT   
F104                             ; 
F104                             ;   Function to set the dma address.
F104                             ; 
F104   EB           PUTDMA:   XCHG      
F105   22 AB F1               SHLD   USERDMA   ;save in our space and then get to
F108   C3 D4 E9               JMP   DEFDMA   ;the bios with this also.
F10B                             ; 
F10B                             ;   Function to return the allocation vector.
F10B                             ; 
F10B   2A B9 F1     GETALOC:   LHLD   ALOCVECT   
F10E   C3 23 F1               JMP   GETPRM1   
F111                             ; 
F111                             ;   Function to return the read-only status vector.
F111                             ; 
F111   2A A7 F1     GETROV:   LHLD   WRTPRT   
F114   C3 23 F1               JMP   GETPRM1   
F117                             ; 
F117                             ;   Function to set the file attributes (read-only, system).
F117                             ; 
F117   CD 4B F0     SETATTR:   CALL   AUTOSEL   ;select proper drive then save attributes.
F11A   CD 35 EC               CALL   SAVEATTR   
F11D   C3 FB EA               JMP   STSTATUS   
F120                             ; 
F120                             ;   Function to return the address of the disk parameter block
F120                             ; for the current drive.
F120                             ; 
F120   2A B5 F1     GETPARM:   LHLD   DISKPB   
F123   22 3F E7     GETPRM1:   SHLD   STATUS   
F126   C9                     RET      
F127                             ; 
F127                             ;   Function to get or set the user number. If (E) was (FF)
F127                             ; then this is a request to return the current user number.
F127                             ; Else set the user number from (E).
F127                             ; 
F127   3A D0 F1     GETUSER:   LDA   EPARAM   ;get parameter.
F12A   FE FF                  CPI   0FFH   ;get user number?
F12C   C2 35 F1               JNZ   SETUSER   
F12F   3A 3B E7               LDA   USERNO   ;yes, just do it.
F132   C3 FB E6               JMP   SETSTAT   
F135   E6 1F        SETUSER:   ANI   1FH   ;no, we should set it instead. keep low
F137   32 3B E7               STA   USERNO   ;bits (0-4) only.
F13A   C9                     RET      
F13B                             ; 
F13B                             ;   Function to read a random record from a file.
F13B                             ; 
F13B   CD 4B F0     RDRANDOM:   CALL   AUTOSEL   ;select proper drive and read.
F13E   C3 8D EF               JMP   READRAN   
F141                             ; 
F141                             ;   Function to compute the file size for random files.
F141                             ; 
F141   CD 4B F0     WTRANDOM:   CALL   AUTOSEL   ;select proper drive and write.
F144   C3 96 EF               JMP   WRITERAN   
F147                             ; 
F147                             ;   Function to compute the size of a random file.
F147                             ; 
F147   CD 4B F0     FILESIZE:   CALL   AUTOSEL   ;select proper drive and check file length
F14A   C3 CC EF               JMP   RANSIZE   
F14D                             ; 
F14D                             ;   Function #37. This allows a program to log off any drives.
F14D                             ; On entry, set (DE) to contain a word with bits set for those
F14D                             ; drives that are to be logged off. The log-in vector and the
F14D                             ; write protect vector will be updated. This must be a M/PM
F14D                             ; special function.
F14D                             ; 
F14D   2A 3D E7     LOGOFF:   LHLD   PARAMS   ;get drives to log off.
F150   7D                     MOV   A,L   ;for each bit that is set, we want
F151   2F                     CMA      ;to clear that bit in (LOGIN)
F152   5F                     MOV   E,A   ;and (WRTPRT).
F153   7C                     MOV   A,H   
F154   2F                     CMA      
F155   2A A9 F1               LHLD   LOGIN   ;reset the login vector.
F158   A4                     ANA   H   
F159   57                     MOV   D,A   
F15A   7D                     MOV   A,L   
F15B   A3                     ANA   E   
F15C   5F                     MOV   E,A   
F15D   2A A7 F1               LHLD   WRTPRT   
F160   EB                     XCHG      
F161   22 A9 F1               SHLD   LOGIN   ;and save.
F164   7D                     MOV   A,L   ;now do the write protect vector.
F165   A3                     ANA   E   
F166   6F                     MOV   L,A   
F167   7C                     MOV   A,H   
F168   A2                     ANA   D   
F169   67                     MOV   H,A   
F16A   22 A7 F1               SHLD   WRTPRT   ;and save. all done.
F16D   C9                     RET      
F16E                             ; 
F16E                             ;   Get here to return to the user.
F16E                             ; 
F16E   3A D8 F1     GOBACK:   LDA   AUTO   ;was auto select activated?
F171   B7                     ORA   A   
F172   CA 8B F1               JZ   GOBACK1   
F175   2A 3D E7               LHLD   PARAMS   ;yes, but was a change made?
F178   36 00                  MVI   M,0   ;(* reset first byte of fcb *)
F17A   3A DA F1               LDA   AUTOFLAG   
F17D   B7                     ORA   A   
F17E   CA 8B F1               JZ   GOBACK1   
F181   77                     MOV   M,A   ;yes, reset first byte properly.
F182   3A D9 F1               LDA   OLDDRV   ;and get the old drive and select it.
F185   32 D0 F1               STA   EPARAM   
F188   CD 3F F0               CALL   SETDSK   
F18B   2A 09 E7     GOBACK1:   LHLD   USRSTACK   ;reset the users stack pointer.
F18E   F9                     SPHL      
F18F   2A 3F E7               LHLD   STATUS   ;get return status.
F192   7D                     MOV   A,L   ;force version 1.4 compatability.
F193   44                     MOV   B,H   
F194   C9                     RET      ;and go back to user.
F195                             ; 
F195                             ;   Function #40. This is a special entry to do random i/o.
F195                             ; For the case where we are writing to unused disk space, this
F195                             ; space will be zeroed out first. This must be a M/PM special
F195                             ; purpose function, because why would any normal program even
F195                             ; care about the previous contents of a sector about to be
F195                             ; written over.
F195                             ; 
F195   CD 4B F0     WTSPECL:   CALL   AUTOSEL   ;select proper drive.
F198   3E 02                  MVI   A,2   ;use special write mode.
F19A   32 CF F1               STA   MODE   
F19D   0E 00                  MVI   C,0   ;set write indicator.
F19F   CD 01 EF               CALL   POSITN1   ;position the file.
F1A2   CC FD ED               CZ   WTSEQ1   ;and write (if no errors).
F1A5   C9                     RET      
F1A6                             ; 
F1A6                             ;**************************************************************
F1A6                             ;*
F1A6                             ;*     BDOS data storage pool.
F1A6                             ;*
F1A6                             ;**************************************************************
F1A6                             ; 
F1A6   E5           EMPTYFCB:   DB   0E5H   ;empty directory segment indicator.
F1A7   00 00        WRTPRT:   DW   0   ;write protect status for all 16 drives.
F1A9   00 00        LOGIN:    DW   0   ;drive active word (1 bit per drive).
F1AB   80 00        USERDMA:   DW   080H   ;user's dma address (defaults to 80h).
F1AD                             ; 
F1AD                             ;   Scratch areas from parameter block.
F1AD                             ; 
F1AD   00 00        SCRATCH1:   DW   0   ;relative position within dir segment for file (0-3).
F1AF   00 00        SCRATCH2:   DW   0   ;last selected track number.
F1B1   00 00        SCRATCH3:   DW   0   ;last selected sector number.
F1B3                             ; 
F1B3                             ;   Disk storage areas from parameter block.
F1B3                             ; 
F1B3   00 00        DIRBUF:   DW   0   ;address of directory buffer to use.
F1B5   00 00        DISKPB:   DW   0   ;contains address of disk parameter block.
F1B7   00 00        CHKVECT:   DW   0   ;address of check vector.
F1B9   00 00        ALOCVECT:   DW   0   ;address of allocation vector (bit map).
F1BB                             ; 
F1BB                             ;   Parameter block returned from the bios.
F1BB                             ; 
F1BB   00 00        SECTORS:   DW   0   ;sectors per track from bios.
F1BD   00           BLKSHFT:   DB   0   ;block shift.
F1BE   00           BLKMASK:   DB   0   ;block mask.
F1BF   00           EXTMASK:   DB   0   ;extent mask.
F1C0   00 00        DSKSIZE:   DW   0   ;disk size from bios (number of blocks-1).
F1C2   00 00        DIRSIZE:   DW   0   ;directory size.
F1C4   00 00        ALLOC0:   DW   0   ;storage for first bytes of bit map (dir space used).
F1C6   00 00        ALLOC1:   DW   0   
F1C8   00 00        OFFSET:   DW   0   ;first usable track number.
F1CA   00 00        XLATE:    DW   0   ;sector translation table address.
F1CC                             ; 
F1CC                             ; 
F1CC   00           CLOSEFLG:   DB   0   ;close flag (=0ffh is extent written ok).
F1CD   00           RDWRTFLG:   DB   0   ;read/write flag (0ffh=read, 0=write).
F1CE   00           FNDSTAT:   DB   0   ;filename found status (0=found first entry).
F1CF   00           MODE:     DB   0   ;I/o mode select (0=random, 1=sequential, 2=special random).
F1D0   00           EPARAM:   DB   0   ;storage for register (E) on entry to bdos.
F1D1   00           RELBLOCK:   DB   0   ;relative position within fcb of block number written.
F1D2   00           COUNTER:   DB   0   ;byte counter for directory name searches.
F1D3   00 00 00 00  SAVEFCB:   DW   0,0   ;save space for address of fcb (for directory searches).
F1D7   00           BIGDISK:   DB   0   ;if =0 then disk is > 256 blocks long.
F1D8   00           AUTO:     DB   0   ;if non-zero, then auto select activated.
F1D9   00           OLDDRV:   DB   0   ;on auto select, storage for previous drive.
F1DA   00           AUTOFLAG:   DB   0   ;if non-zero, then auto select changed drives.
F1DB   00           SAVNXT:   DB   0   ;storage for next record number to access.
F1DC   00           SAVEXT:   DB   0   ;storage for extent number of file.
F1DD   00 00        SAVNREC:   DW   0   ;storage for number of records in file.
F1DF   00 00        BLKNMBR:   DW   0   ;block number (physical sector) used within a file or logical sector.
F1E1   00 00        LOGSECT:   DW   0   ;starting logical (128 byte) sector of block (physical sector).
F1E3   00           FCBPOS:   DB   0   ;relative position within buffer for fcb of file of interest.
F1E4   00 00        FILEPOS:   DW   0   ;files position within directory (0 to max entries -1).
F1E6                             ; 
F1E6                             ;   Disk directory buffer checksum bytes. One for each of the
F1E6                             ; 16 possible drives.
F1E6                             ; 
F1E6   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CKSUMTBL:   DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
F1F6                             ; 
F1F6                             ;   Extra space ?
F1F6                             ; 
F1F6   00 00 00 00            DB   0,0,0,0   
F1FA                             ; 
F1FA                             ;**************************************************************
F1FA                             ;*
F1FA                             ;*        B I O S   J U M P   T A B L E
F1FA                             ;*
F1FA                             ;**************************************************************
F1FA                             ; 
F1FA   C3 9C F2     BOOT1:    JMP   BOOT   ;NOTE WE USE FAKE DESTINATIONS
F1FD   C3 A7 F2     WBOOT1:   JMP   WBOOT   
F200   C3 1A F3     CONST1:   JMP   CONST   
F203   C3 27 F3     CONIN1:   JMP   CONIN   
F206   C3 35 F3     CONOUT1:   JMP   CONOUT   
F209   C3 44 F3     LIST1:    JMP   LIST   
F20C   C3 48 F3     PUNCH1:   JMP   PUNCH   
F20F   C3 4A F3     READER1:   JMP   READER   
F212   C3 4F F3     HOME1:    JMP   HOME   
F215   C3 65 F3     SELDSK1:   JMP   SELDSK   
F218   C3 98 F3     SETTRK1:   JMP   SETTRK   
F21B   C3 AC F3     SETSEC1:   JMP   SETSEC   
F21E   C3 C3 F3     SETDMA1:   JMP   SETDMA   
F221   C3 C9 F3     READ1:    JMP   READ   
F224   C3 21 F4     WRITE1:   JMP   WRITE   
F227                             ;PRSTAT1	    JMP	PRSTAT
F227   C3 C0 F3     SECTRAN1:   JMP   SECTRAN   
F22A                             ; 
F22A                             ;*
F22A                             ;******************   E N D   O F   C P / M   *****************
F22A                             ;*
F22A                             ;******************** CP/M BIOS*********************************
F22A                             ;	skeletal cbios for first level of CP/M 2.0 alteration
F22A                             ; 
F22A                MSIZE:    EQU   62   ;cp/m version memory size in kilobytes
F22A                             ; 
F22A                             ;	"bias" is address offset from 3400h for memory systems
F22A                             ;	than 16k (referred to as"b" throughout the text)
F22A                             ; 
F22A                BIAS:     EQU   (msize-20)*1024   
F200                          .ORG   BIOS   ;origin of this program
F200                NSECTS:   EQU   ($-ccp)/128   ;warm start sector count
F200                             ; 
F200                             ;	jump vector for individual subroutines
F200                             ; 
F200   C3 9C F2               JMP   boot   ;cold start
F203   C3 A7 F2     WBOOTE:   JMP   wboot   ;warm start
F206   C3 1A F3               JMP   const   ;console status
F209   C3 27 F3               JMP   conin   ;console character in
F20C   C3 35 F3               JMP   conout   ;console character out
F20F   C3 44 F3               JMP   list   ;list character out
F212   C3 48 F3               JMP   punch   ;punch character out
F215   C3 4A F3               JMP   reader   ;reader character out
F218   C3 4F F3               JMP   home   ;move head to home position
F21B   C3 65 F3               JMP   seldsk   ;select disk
F21E   C3 98 F3               JMP   settrk   ;set track number
F221   C3 AC F3               JMP   setsec   ;set sector number
F224   C3 C3 F3               JMP   setdma   ;set dma address
F227   C3 C9 F3               JMP   read   ;read disk
F22A   C3 21 F4               JMP   write   ;write disk
F22D   C3 46 F3               JMP   listst   ;return list status
F230   C3 C0 F3               JMP   sectran   ;sector translate
F233                             ; 
F233                             ;	fixed data tables for four-drive standard
F233                             ;	ibm-compatible 8" disks
F233                             ; 
F233                             ;	disk Parameter header for disk 00
F233   73 F2 00 00  DPBASE:   DW   trans,0000h   
F237   00 00 00 00            DW   0000h,0000h   
F23B   A6 F4 8D F2            DW   dirbf,dpblk   
F23F   A2 F5 26 F5            DW   chk00,all00   
F243                             ;	disk parameter header for disk 01
F243   73 F2 00 00            DW   trans,0000h   
F247   00 00 00 00            DW   0000h,0000h   
F24B   A6 F4 8D F2            DW   dirbf,dpblk   
F24F   B2 F5 45 F5            DW   chk01,all01   
F253                             ;	disk parameter header for disk 02
F253   73 F2 00 00            DW   trans,0000h   
F257   00 00 00 00            DW   0000h,0000h   
F25B   A6 F4 8D F2            DW   dirbf,dpblk   
F25F   C2 F5 64 F5            DW   chk02,all02   
F263                             ;	disk parameter header for disk 03
F263   73 F2 00 00            DW   trans,0000h   
F267   00 00 00 00            DW   0000h,0000h   
F26B   A6 F4 8D F2            DW   dirbf,dpblk   
F26F   D2 F5 83 F5            DW   chk03,all03   
F273                             ; 
F273                             ;	sector translate vector
F273   01 07 0D 13  TRANS:    DB   1,7,13,19   ;sectors  1,  2,  3,  4
F277   19 05 0B 11            DB   25,5,11,17   ;sectors  5,  6,  7,  6
F27B   17 03 09 0F            DB   23,3,9,15   ;sectors  9, 10, 11, 12
F27F   15 02 08 0E            DB   21,2,8,14   ;sectors 13, 14, 15, 16
F283   14 1A 06 0C            DB   20,26,6,12   ;sectors 17, 18, 19, 20
F287   12 18 04 0A            DB   18,24,4,10   ;sectors 21, 22, 23, 24
F28B   10 16                  DB   16,22   ;sectors 25, 26
F28D                             ; 
F28D                DPBLK:       ;disk parameter block, common to all disks
F28D   1A 00                  DW   26   ;sectors per track
F28F   03                     DB   3   ;block shift factor
F290   07                     DB   7   ;block mask
F291   00                     DB   0   ;null mask
F292   F2 00                  DW   242   ;disk size-1
F294   3F 00                  DW   63   ;directory max
F296   C0                     DB   192   ;alloc 0
F297   00                     DB   0   ;alloc 1
F298   10 00                  DW   16   ;check size
F29A   02 00                  DW   2   ;track offset
F29C                             ; 
F29C                             ;	end of fixed tables
F29C                             ; 
F29C                             ;	individual subroutines to perform each function
F29C                BOOT:        ;simplest case is to just perform parameter initialization
F29C   F3                     DI      
F29D   AF                     XRA   a   ;zero in the accum
F29E   32 03 80               STA   iobyte   ;clear the iobyte
F2A1   32 04 80               STA   cdisk   ;select disk zero
F2A4   C3 F7 F2               JMP   gocpm   ;initialize and go to cp/m
F2A7                             ; 
F2A7                WBOOT:       ;simplest case is to read the disk until all sectors loaded
F2A7   F3                     DI      ;!!!!!
F2A8   21 80 80               LXI   H,TBUFF   ;!!!!!
F2AB   22 A3 F4               SHLD   DMAAD   
F2AE   31 80 80               LXI   sp,DEFSTCK   ;use space below buffer for stack !!!!!
F2B1   0E 00                  MVI   c,0   ;select disk 0
F2B3   CD 65 F3               CALL   seldsk   
F2B6   CD 4F F3               CALL   home   ;go to track 00
F2B9                             ; 
F2B9   06 04                  MVI   b,4   ; nsects ;b counts * of sectors to load !!!!!
F2BB   0E 00                  MVI   c,0   ;c has the current track number
F2BD   16 02                  MVI   d,2   ;d has the next sector to read
F2BF                             ;	note that we begin by reading track 0, sector 2 since sector 1
F2BF                             ;	contains the cold start loader, which is skipped in a warm start
F2BF   21 00 DC               LXI   h,ccp   ;base of cp/m (initial load point)
F2C2                LOAD1:       ;load	one more sector
F2C2   C5                     PUSH   b   ;save sector count, current track
F2C3   D5                     PUSH   d   ;save next sector to read
F2C4   E5                     PUSH   h   ;save dma address
F2C5   4A                     MOV   c,d   ;get sector address to register C
F2C6   CD AC F3               CALL   setsec   ;set sector address from register C
F2C9   C1                     POP   b   ;recall dma address to b, C
F2CA   C5                     PUSH   b   ;replace on stack for later recall
F2CB   CD C3 F3               CALL   setdma   ;set dma address from b, C
F2CE                             ; 
F2CE                             ;	drive set to 0, track set, sector set, dma address set
F2CE   CD C9 F3               CALL   read   
F2D1   FE 00                  CPI   00h   ;any errors?
F2D3   C2 A7 F2               JNZ   wboot   ;retry the entire boot if an error occurs
F2D6                             ; 
F2D6                             ;	no error, move to next sector
F2D6   E1                     POP   h   ;recall dma address
F2D7   11 80 00               LXI   d,128   ;dma=dma+128
F2DA   19                     DAD   d   ;new dma address is in h, l
F2DB   D1                     POP   d   ;recall sector address
F2DC   C1                     POP   b   ;recall number of sectors remaining, and current trk
F2DD   05                     DCR   b   ;sectors=sectors-1
F2DE   CA F7 F2               JZ   gocpm   ;transfer to cp/m if all have been loaded
F2E1                             ; 
F2E1                             ;	more	sectors remain to load, check for track change
F2E1   14                     INR   d   
F2E2   7A                     MOV   a,d   ;sector=27?, if so, change tracks
F2E3   FE 1B                  CPI   27   
F2E5   DA C2 F2               JC   load1   ;carry generated if sector<27
F2E8                             ; 
F2E8                             ;	end of	current track,	go to next track
F2E8   16 01                  MVI   d,1   ;begin with first sector of next track
F2EA   0C                     INR   c   ;track=track+1
F2EB                             ; 
F2EB                             ;	save	register state, and change tracks
F2EB   C5                     PUSH   b   
F2EC   D5                     PUSH   d   
F2ED   E5                     PUSH   h   
F2EE   CD 98 F3               CALL   settrk   ;track address set from register c
F2F1   E1                     POP   h   
F2F2   D1                     POP   d   
F2F3   C1                     POP   b   
F2F4   C3 C2 F2               JMP   load1   ;for another sector
F2F7                             ; 
F2F7                             ;	end of	load operation, set parameters and go to cp/m
F2F7                GOCPM:       
F2F7   3E C3                  MVI   a,0c3h   ;c3 is a jmp instruction
F2F9   32 00 00               STA   0   ;for jmp to wboot
F2FC   21 03 F2               LXI   h,wboote   ;wboot entry point
F2FF   22 01 00               SHLD   1   ;set address field for jmp at 0
F302                             ; 
F302   32 05 00               STA   5   ;for jmp to bdos
F305   21 00 E4               LXI   h,bdos   ;bdos entry point
F308   22 06 00               SHLD   6   ;address field of Jump at 5 to bdos
F30B                             ; 
F30B   2A A3 F4               LHLD   DMAAD   
F30E   E5                     PUSH   H   
F30F   C1                     POP   B   
F310   CD C3 F3               CALL   setdma   
F313                             ; 
F313                             ;EI       ;enable the interrupt system !!!!!
F313   3A 04 80               LDA   cdisk   ;get current disk number
F316   4F                     MOV   c,a   ;send to the ccp
F317   C3 00 DC               JMP   ccp   ;go to cp/m for further processing
F31A                             ; 
F31A                             ; 
F31A                             ;	simple i/o handlers (must be filled in by user)
F31A                             ;	in each case, the entry point is provided, with space reserved
F31A                             ;	to insert your own code
F31A                             ; 
F31A                CONST:       ;console status, return 0ffh if character ready, 00h if not
F31A   DB DE                  IN   0DEh   
F31C   E6 02                  ANI   02   
F31E   CA 24 F3               JZ   NOCHAR   
F321   3E FF                  MVI   A,0FFh   
F323   C9                     RET      
F324   3E 00        NOCHAR:   MVI   A,00h   
F326   C9                     RET      
F327                             ; 
F327                CONIN:       ;console character into register a
F327   CD 2D F3               CALL   WAITOUT2   
F32A   DB DF                  IN   0DFh   
F32C                             ;ANI     7Fh ;strip parity bit
F32C   C9                     RET      
F32D                WAITOUT2:      
F32D   DB DE                  IN   0DEh   
F32F   E6 01                  ANI   01   
F331   C2 2D F3               JNZ   WAITOUT2   
F334   C9                     RET      
F335                             ; 
F335                CONOUT:      ;console character output from register c
F335   CD 3C F3               CALL   WAITOUT   
F338   79                     MOV   A,C   
F339                             ;    ANI     7Fh ;drop 8th bit
F339   D3 DF                  OUT   0DFh   
F33B   C9                     RET      
F33C   DB DE        WAITOUT:   IN   0DEh   
F33E   E6 02                  ANI   02h   
F340   CA 3C F3               JZ   WAITOUT   
F343   C9                     RET      
F344                             ; 
F344                LIST:        ;list character from register c
F344   79                     MOV   a,c   ;character to register a
F345   C9                     RET      ;null subroutine
F346                             ; 
F346                LISTST:      ;return list status (0 if not ready, 1 if ready)
F346   AF                     XRA   a   ;0 is always ok to return
F347   C9                     RET      
F348                             ; 
F348                PUNCH:       ;punch	character from	register C
F348   79                     MOV   a,c   ;character to register a
F349   C9                     RET      ;null subroutine
F34A                             ; 
F34A                             ; 
F34A                READER:      ;reader character into register a from reader device
F34A   3E 1A                  MVI   a,1ah   ;enter end of file for now (replace later)
F34C   E6 7F                  ANI   7fh   ;remember to strip parity bit
F34E   C9                     RET      
F34F                             ; 
F34F                             ; 
F34F                             ;	i/o drivers for the disk follow
F34F                             ;	for now, we will simply store the parameters away for use
F34F                             ;	in the read and write	subroutines
F34F                             ; 
F34F                HOME:        ;move to the track 00	position of current drive
F34F                             ;	translate this call into a settrk call with Parameter 00
F34F   16 01                  MVI   D,01H   ; D - комманда HOME
F351   06 00                  MVI   B,00h   ; B - неиспользуеммые данные
F353   CD 3A F4               CALL   SENDCMD   
F356   3E 00                  MVI   A,0   ;select track 0
F358   32 9F F4               STA   track   
F35B   CD 6C F4               CALL   LOOP   
F35E   CD 6C F4               CALL   LOOP   
F361   CD 6C F4               CALL   LOOP   
F364   C9                     RET      ;we will move to 00 on first read/write
F365                             ; 
F365                SELDSK:      ;select disk given by register c
F365   16 02                  MVI   D,02H   ; D - комманда
F367   41                     MOV   B,C   ; CPM wants drive in C and
F368   CD 3A F4               CALL   SENDCMD   
F36B   CD 6C F4               CALL   LOOP   
F36E   CD 6C F4               CALL   LOOP   
F371   CD 6C F4               CALL   LOOP   
F374   C9                     RET      
F375   21 00 00               LXI   h,0000h   ;error return code
F378   79                     MOV   a,c   
F379   32 A5 F4               STA   diskno   
F37C   FE 04                  CPI   4   ;must be between 0 and 3
F37E   D0                     RNC      ;no carry if 4, 5,...
F37F                             ;	disk number is in the proper range
F37F                          DS   10   ;space for disk select
F389                             ;	compute proper disk Parameter header address
F389   3A A5 F4               LDA   diskno   
F38C   6F                     MOV   l,a   ;l=disk number 0, 1, 2, 3
F38D   26 00                  MVI   h,0   ;high order zero
F38F   29                     DAD   h   ;*2
F390   29                     DAD   h   ;*4
F391   29                     DAD   h   ;*8
F392   29                     DAD   h   ;*16 (size of each header)
F393   11 33 F2               LXI   d,dpbase   
F396   19                     DAD   d   ;hl=,dpbase (diskno*16)
F397   C9                     RET      
F398                             ; 
F398                SETTRK:      ;set track given by register c
F398   79                     MOV   a,c   
F399   32 9F F4               STA   track   
F39C   16 04                  MVI   D,04h   ; D - комманда
F39E   41                     MOV   B,C   ; Пока ограничимся только 256 дорожками, поэтому передаем
F39F   CD 3A F4               CALL   SENDCMD   ; только младший байт С
F3A2   CD 6C F4               CALL   LOOP   
F3A5   CD 6C F4               CALL   LOOP   
F3A8   CD 6C F4               CALL   LOOP   
F3AB   C9                     RET      
F3AC                             ; 
F3AC                SETSEC:      ;set sector given by register c
F3AC   79                     MOV   a,c   
F3AD   32 A1 F4               STA   sector   
F3B0   16 03                  MVI   D,03h   ; D - комманда
F3B2   41                     MOV   B,C   ; Пока ограничимся только 256 секторами, поэтому передаем
F3B3   CD 3A F4               CALL   SENDCMD   ; только младший байт С
F3B6   CD 6C F4               CALL   LOOP   
F3B9   CD 6C F4               CALL   LOOP   
F3BC   CD 6C F4               CALL   LOOP   
F3BF   C9                     RET      
F3C0                             ; 
F3C0                             ; 
F3C0                SECTRAN:      
F3C0                             ;translate the sector given by bc using the
F3C0                             ;translate table given by de
F3C0                             ;XCHG     ;hl=.trans
F3C0                             ;DAD     b ;hl=.trans (sector)
F3C0                             ;MOV     l,m ;l=trans (sector)
F3C0                             ;MVI     h,0 ;hl=trans (sector)
F3C0                             ;Пpеобpазование номеpа сектоpа
F3C0                             ; паpаметp вызова:  BC - не пpеобpазованный номеp (00....) сектора
F3C0                             ;                   DE - адpес таблицы пpеобpазования
F3C0                             ;паpаметp возвpата: HL - пpеобpазованный номеp сектоpа
F3C0                             ; Тут  что-то  было  про баг если просто не делать ничего.
F3C0   60                     MOV   H,B   
F3C1   69                     MOV   L,C   
F3C2   C9                     RET      ;with value in hl
F3C3                             ; 
F3C3                SETDMA:      ;set	dma address given by registers b and c
F3C3                             ; Установка адpеса буфеpа
F3C3                             ; паpаметp вызова:      BC - адpес буфеpа
F3C3                             ; паpаметp возвpата:    -
F3C3                             ;set	dma address given by registers b and c
F3C3   69                     MOV   l,c   ;low order address
F3C4   60                     MOV   h,b   ;high order address
F3C5   22 A3 F4               SHLD   dmaad   ;save the address
F3C8   C9                     RET      
F3C9                             ; 
F3C9                READ:        ;perform read operation (usually this is similar to write
F3C9                             ;	so we will allow space to set up read command, then use
F3C9                             ;	common code in write)
F3C9   CD 77 F4               CALL   INITOUT   
F3CC   06 00                  MVI   B,00h   ; B - данные которые мы хотим отправить накопителю  перед чтением
F3CE   16 00                  MVI   D,00h   ; D - комманда  чтения (000)
F3D0   CD 3A F4               CALL   SENDCMD   ; Отправляем накопителю желание считать сектор
F3D3   2A A3 F4               LHLD   DMAAD   
F3D6   36 00                  MVI   M,00h   
F3D8   16 80                  MVI   D,80h   
F3DA   FB                     EI      ; Разрешаем прерывания
F3DB   3E 18                  MVI   A,18h   ; 
F3DD   30                     SIM      ; Разрешаем прерывания
F3DE                CYCLE:       
F3DE   C3 DE F3               JMP   CYCLE   
F3E1                SECTORDONE:      
F3E1   F3                     DI      
F3E2   CD 77 F4               CALL   INITOUT   
F3E5   CD 6C F4               CALL   LOOP   
F3E8   3E 00                  MVI   A,0   ; NO ERROR
F3EA   33                     INX   SP   
F3EB   33                     INX   SP   
F3EC   CD 95 F4               CALL   MEGALOOP   
F3EF   C9                     RET      
F3F0                RECINTLOW:      ;  Сюда мы попадаем  если сработало прерывание
F3F0   CD 80 F4               CALL   INITIN   
F3F3   7E                     MOV   A,M   
F3F4   A7                     ANA   A   
F3F5   C2 00 F4               JNZ   RECINTHIGH   
F3F8   DB 00                  IN   00   
F3FA   77                     MOV   M,A   
F3FB   FB                     EI      ; Разрешаем прерывания
F3FC   3E 18                  MVI   A,18h   ; 
F3FE   30                     SIM      ; Включаем INT 7.5
F3FF   C9                     RET      
F400                RECINTHIGH:      
F400   CD 80 F4               CALL   INITIN   
F403   4E                     MOV   C,M   
F404   3E F0                  MVI   A,0F0h   ; 11110000
F406   A1                     ANA   C   
F407   0F                     RRC      
F408   0F                     RRC      
F409   0F                     RRC      
F40A   0F                     RRC      
F40B   4F                     MOV   C,A   
F40C   DB 00                  IN   00   
F40E   47                     MOV   B,A   
F40F   3E F0                  MVI   A,0F0h   ; 11110000
F411   A0                     ANA   B   
F412   47                     MOV   B,A   
F413   B1                     ORA   C   
F414   77                     MOV   M,A   
F415   23                     INX   H   
F416   36 00                  MVI   M,00h   
F418   15                     DCR   D   
F419   CA E1 F3               JZ   SECTORDONE   
F41C   FB                     EI      
F41D   3E 18                  MVI   A,18h   
F41F   30                     SIM      
F420   C9                     RET      
F421                             ; 
F421                WRITE:       ;perform a write operation
F421                             ; Адрес начала сектора в DMA
F421                             ; Попробуем весь сектор передать как  128 SENDCMD.
F421                             ; B - данные
F421                             ; D - комманда
F421   CD 77 F4               CALL   INITOUT   
F424   2A A3 F4               LHLD   DMAAD   ; Старт DMA
F427   16 07                  MVI   D,07h   ; Комманда записи
F429   1E 80                  MVI   E,80h   ; размер сектора
F42B                NEXTBYTE:      
F42B   16 07                  MVI   D,07h   ; Комманда записи
F42D   46                     MOV   B,M   ; Берем из памяти байт
F42E   CD 3A F4               CALL   SENDCMD   ; Отправляем байт
F431   23                     INX   H   ; Увеличиваем адрес
F432   1D                     DCR   E   ; Уменьшаем счетчик байт
F433   C2 2B F4               JNZ   NEXTBYTE   ; Если не последний шлем далее
F436   C9                     RET      
F437   3E 00                  MVI   A,0   ;error condition
F439                             ; 
F439                WAITIO:      ;enter	here from read	and write to perform the actual i/o
F439                             ;	operation. return a 00h in register a if the operation completes
F439                             ;	properly, and 0lh if an error occurs during the read or write
F439                             ; 
F439                             ;	in this case, we have saved the disk number in "diskno" (0, 1)
F439                             ;			the track number in "track" (0-76)
F439                             ;			the sector number in "sector" (1-26)
F439                             ;			the dma address in "dmaad" (0-65535)
F439   C9                     RET      ;replaced when filled-in
F43A                             ; 
F43A                SENDCMD:      ; B - данные
F43A                             ; D - комманда
F43A   CD 77 F4               CALL   INITOUT   
F43D   48                     MOV   C,B   ; в BC у нас 2 копии данных В-h C-l
F43E   3E F0                  MVI   A,0F0h   ; 11110000
F440   A0                     ANA   B   
F441   47                     MOV   B,A   
F442   3E 0F                  MVI   A,0Fh   ; 00001111
F444   A1                     ANA   C   
F445   07                     RLC      
F446   07                     RLC      ; Сдвигаем данные  младшей половинки до конца влево
F447   07                     RLC      ; и получаем       обе половинки справа
F448   07                     RLC      
F449   4F                     MOV   C,A   
F44A   7A                     MOV   A,D   ; комманда
F44B   07                     RLC      ; Сдвигаем комманду на место
F44C   B0                     ORA   B   ; Добавляем к половинкам код комманды.
F44D   47                     MOV   B,A   
F44E   7A                     MOV   A,D   ; комманда
F44F   07                     RLC      ; Сдвигаем комманду на место
F450   B1                     ORA   C   ; Добавляем к половинкам код комманды.
F451   4F                     MOV   C,A   
F452                SENDBYTE:      ; BC содержит половинки, код комманды и 0 в младшем бите
F452   79                     MOV   A,C   
F453   3C                     INR   A   ; Поднимаем младший бит  чтобы диск проснулся
F454   D3 00                  OUT   00h   ; Выводим  младшую половину в порт
F456   CD 6C F4               CALL   LOOP   
F459   3E 00                  MVI   A,00h   
F45B   D3 00                  OUT   00h   ; обнуляем порт
F45D   CD 6C F4               CALL   LOOP   
F460   78                     MOV   A,B   
F461   3C                     INR   A   ; Поднимаем младший бит
F462   D3 00                  OUT   00h   ; Выводим  старшую половину в порт для для совместимости
F464   CD 6C F4               CALL   LOOP   ; даже комманды без данных передаем в 2 такта
F467   3E 00                  MVI   A,00h   
F469   D3 00                  OUT   00h   ; обнуляем порт
F46B                             ;CALL    LOOP
F46B   C9                     RET      
F46C                LOOP:        
F46C   16 80                  MVI   D,80h   ;delay a little
F46E   00           LOOP2:    NOP      
F46F   00                     NOP      
F470   00                     NOP      
F471   00                     NOP      
F472   15                     DCR   D   ;decrement counter
F473   C2 6E F4               JNZ   LOOP2   
F476   C9                     RET      
F477                INITOUT:      
F477   3E 80                  MVI   A,80h   
F479   D3 07                  OUT   07H   
F47B   3E 00                  MVI   A,0h   
F47D   D3 00                  OUT   00h   
F47F   C9                     RET      
F480                INITIN:      
F480   3E 90                  MVI   A,90h   
F482   D3 07                  OUT   07h   
F484   3E 00                  MVI   A,0h   
F486   D3 00                  OUT   00h   
F488   C9                     RET      
F489                BYTEOUT:      
F489                             ; ВХОД C  - Байт для вывода
F489   CD 3C F3               CALL   WAITOUT   ; Выход A - Отправленный байт
F48C   79                     MOV   A,C   
F48D   D3 DF                  OUT   0DFh   
F48F   C9                     RET      
F490   3E 15        ACIAINIT:   MVI   A,15h   ;ACIA init (21) 115200-8-N-1
F492   D3 DE                  OUT   0DEh   
F494   C9                     RET      
F495                MEGALOOP:      
F495   3E FF                  MVI   A,0FFh   
F497                MEGALOOP2:      
F497   CD 6C F4               CALL   LOOP   
F49A   3D                     DCR   A   
F49B   C2 97 F4               JNZ   MEGALOOP2   
F49E   C9                     RET      
F49F                             ;	the remainder of the cbios is reserved uninitialized
F49F                             ;	data area, and does not need to be a Part of the
F49F                             ;	system	memory image (the space must be available,
F49F                             ;	however, between"begdat" and"enddat").
F49F                             ; 
F49F                TRACK:    DS   2   ;two bytes for expansion
F4A1                SECTOR:   DS   2   ;two bytes for expansion
F4A3                DMAAD:    DS   2   ;direct memory address
F4A5                DISKNO:   DS   1   ;disk number 0-15
F4A6                             ; 
F4A6                             ;	scratch ram area for bdos use
F4A6                BEGDAT:   EQU   $   ;beginning of data area
F4A6                DIRBF:    DS   128   ;scratch directory area
F526                ALL00:    DS   31   ;allocation vector 0
F545                ALL01:    DS   31   ;allocation vector 1
F564                ALL02:    DS   31   ;allocation vector 2
F583                ALL03:    DS   31   ;allocation vector 3
F5A2                CHK00:    DS   16   ;check vector 0
F5B2                CHK01:    DS   16   ;check vector 1
F5C2                CHK02:    DS   16   ;check vector 2
F5D2                CHK03:    DS   16   ;check vector 3
F5E2                             ; 
F5E2                ENDDAT:   EQU   $   ;end of data area
F5E2                DATSIZ:   EQU   $-begdat   ;	;size of data area
F5E2                          END      
